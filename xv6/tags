!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACCII_SIZE	drawingAPI.h	8;"	d
ALIGNING	common.h	14;"	d
ALT	kbd.h	11;"	d
AS	Makefile	/^AS = $(TOOLPREFIX)gas$/;"	m
ASCII_HEIGHT	drawingAPI.h	7;"	d
ASCII_NUM	drawingAPI.h	5;"	d
ASCII_WIDTH	drawingAPI.h	6;"	d
ASFLAGS	Makefile	/^ASFLAGS = -m32 -gdwarf-2 -Wa,-divide$/;"	m
ASSERT	lapic.c	24;"	d	file:
Align	umalloc.c	/^typedef long Align;$/;"	t	file:
BACK	sh.c	12;"	d	file:
BACKSPACE	console.c	159;"	d	file:
BBLOCK	fs.h	46;"	d
BCAST	lapic.c	27;"	d	file:
BIG	usertests.c	1452;"	d	file:
BINARY	common.h	19;"	d
BITMAPFILEHEADER	bitmap.h	/^} BITMAPFILEHEADER;$/;"	t	typeref:struct:tagBITMAPFILEHEADER
BITMAPINFOHEADER	bitmap.h	/^} BITMAPINFOHEADER;$/;"	t	typeref:struct:tagBITMAPINFOHEADER
BITMAP_H	bitmap.h	2;"	d
BORDERLINE_COLOR	windowStyle.h	3;"	d
BOTTOMBAR_COLOR	windowStyle.h	6;"	d
BOTTOMBAR_HEIGHT	windowStyle.h	7;"	d
BPB	fs.h	43;"	d
BSIZE	fs.h	12;"	d
BUFFER_SIZE	common.h	29;"	d
BUFSIZE	sound.h	27;"	d
BUF_SIZE	cp.c	7;"	d	file:
BUF_SIZE	editor.c	7;"	d	file:
BUF_SIZE	mv.c	7;"	d	file:
BUF_SIZE	play.asm	/^#define BUF_SIZE  (SINGLE_BUF_SIZE * 8)$/;"	d
BUF_SIZE	play.c	8;"	d	file:
BUSY	lapic.c	28;"	d	file:
BUTTON_HEIGHT	finder.c	18;"	d	file:
BUTTON_WIDTH	finder.c	17;"	d	file:
BYTE	bitmap.h	/^typedef unsigned char BYTE;$/;"	t
B_BUSY	buf.h	10;"	d
B_DIRTY	buf.h	12;"	d
B_VALID	buf.h	11;"	d
Bit_stream_struc	common.h	/^} Bit_stream_struc;$/;"	t	typeref:struct:bit_stream_struc
C	console.c	378;"	d	file:
C	kbd.h	32;"	d
CAPSLOCK	kbd.h	13;"	d
CC	Makefile	/^CC = $(TOOLPREFIX)gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer$/;"	m
CLICKABLE_H	clickable.h	2;"	d
CMOS_PORT	lapic.c	134;"	d	file:
CMOS_RETURN	lapic.c	135;"	d	file:
CMOS_STATA	lapic.c	174;"	d	file:
CMOS_STATB	lapic.c	175;"	d	file:
CMOS_UIP	lapic.c	176;"	d	file:
COM1	uart.c	14;"	d	file:
COMMANDMAXLENDTH	console.c	18;"	d	file:
COMMANDNUM	console.c	19;"	d	file:
COMMANDNUM	sh.c	16;"	d	file:
CONSOLE	file.h	38;"	d
CONTEXT_H	context.h	2;"	d
CONV	lapic.c	225;"	d	file:
CONV	lapic.c	232;"	d	file:
CPUS	Makefile	/^CPUS := 2$/;"	m
CR0_AM	mmu.h	35;"	d
CR0_CD	mmu.h	37;"	d
CR0_EM	mmu.h	30;"	d
CR0_ET	mmu.h	32;"	d
CR0_MP	mmu.h	29;"	d
CR0_NE	mmu.h	33;"	d
CR0_NW	mmu.h	36;"	d
CR0_PE	mmu.h	28;"	d
CR0_PG	mmu.h	38;"	d
CR0_TS	mmu.h	31;"	d
CR0_WP	mmu.h	34;"	d
CR4_PSE	mmu.h	40;"	d
CRTPORT	console.c	160;"	d	file:
CTL	kbd.h	10;"	d
Ci	decodemp3.c	/^double Ci[8]={-0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142,-0.0037};$/;"	v
Clickable	clickable.h	/^typedef struct Clickable$/;"	s
Clickable	clickable.h	/^} Clickable;$/;"	t	typeref:struct:Clickable
ClickableManager	.asm	/^ClickableManager initClickManager(struct Context c)$/;"	l
ClickableManager	clickable.h	/^typedef struct ClickableManager$/;"	s
ClickableManager	clickable.h	/^} ClickableManager;$/;"	t	typeref:struct:ClickableManager
Context	context.h	/^typedef struct Context$/;"	s
Context	context.h	/^} Context;$/;"	t	typeref:struct:Context
DAY	lapic.c	181;"	d	file:
DEASSERT	lapic.c	25;"	d	file:
DELIVS	lapic.c	23;"	d	file:
DEVSPACE	memlayout.h	5;"	d
DIRSIZ	fs.h	49;"	d
DMA_BUF_NUM	sound.h	3;"	d
DMA_BUF_SIZE	sound.h	5;"	d
DMA_SMP_NUM	sound.h	4;"	d
DOUBLE_CLICK	mouse.h	4;"	d
DOUBLE_CLICK_DELAY	mouse.h	8;"	d
DPL_USER	mmu.h	79;"	d
DRAGGING	mouse.h	5;"	d
DRAG_RELEASE	mouse.h	6;"	d
DRAWINGAPI_H	drawingAPI.h	2;"	d
DWORD	bitmap.h	/^typedef unsigned long DWORD;$/;"	t
Disassembly	.asm	/^Disassembly of section .text:$/;"	l
Disassembly	cat.asm	/^Disassembly of section .text:$/;"	l
Disassembly	decode.asm	/^Disassembly of section .text:$/;"	l
Disassembly	echo.asm	/^Disassembly of section .text:$/;"	l
Disassembly	forktest.asm	/^Disassembly of section .text:$/;"	l
Disassembly	grep.asm	/^Disassembly of section .text:$/;"	l
Disassembly	init.asm	/^Disassembly of section .text:$/;"	l
Disassembly	kill.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ln.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ls.asm	/^Disassembly of section .text:$/;"	l
Disassembly	mkdir.asm	/^Disassembly of section .text:$/;"	l
Disassembly	pause.asm	/^Disassembly of section .text:$/;"	l
Disassembly	play.asm	/^Disassembly of section .text:$/;"	l
E0ESC	kbd.h	17;"	d
ELF_MAGIC	elf.h	3;"	d
ELF_PROG_FLAG_EXEC	elf.h	40;"	d
ELF_PROG_FLAG_READ	elf.h	42;"	d
ELF_PROG_FLAG_WRITE	elf.h	41;"	d
ELF_PROG_LOAD	elf.h	37;"	d
EMBRYO	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
ENABLE	lapic.c	18;"	d	file:
EOI	lapic.c	16;"	d	file:
ERROR	lapic.c	37;"	d	file:
ESR	lapic.c	19;"	d	file:
EXEC	sh.c	8;"	d	file:
EXTMEM	memlayout.h	3;"	d
EXTRA	Makefile	/^EXTRA=\\$/;"	m
FALSE	common.h	22;"	d
FD_INODE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon12
FD_NONE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon12
FD_PIPE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon12
FILES	Makefile	/^FILES = $(shell grep -v '^\\#' runoff.list)$/;"	m
FILE_ICON_BIG	.asm	/^#define FILE_ICON_BIG 0$/;"	d
FILE_ICON_BIG	finder.c	209;"	d	file:
FILE_ICON_SMALL	.asm	/^#define FILE_ICON_SMALL 1$/;"	d
FILE_ICON_SMALL	finder.c	210;"	d	file:
FIXED	lapic.c	29;"	d	file:
FL_AC	mmu.h	22;"	d
FL_AF	mmu.h	7;"	d
FL_CF	mmu.h	5;"	d
FL_DF	mmu.h	12;"	d
FL_ID	mmu.h	25;"	d
FL_IF	mmu.h	11;"	d
FL_IOPL_0	mmu.h	15;"	d
FL_IOPL_1	mmu.h	16;"	d
FL_IOPL_2	mmu.h	17;"	d
FL_IOPL_3	mmu.h	18;"	d
FL_IOPL_MASK	mmu.h	14;"	d
FL_NT	mmu.h	19;"	d
FL_OF	mmu.h	13;"	d
FL_PF	mmu.h	6;"	d
FL_RF	mmu.h	20;"	d
FL_SF	mmu.h	9;"	d
FL_TF	mmu.h	10;"	d
FL_VIF	mmu.h	23;"	d
FL_VIP	mmu.h	24;"	d
FL_VM	mmu.h	21;"	d
FL_ZF	mmu.h	8;"	d
FOLDER_ICON_BIG	.asm	/^#define FOLDER_ICON_BIG 2$/;"	d
FOLDER_ICON_BIG	finder.c	211;"	d	file:
FOLDER_ICON_SMALL	.asm	/^#define FOLDER_ICON_SMALL 3$/;"	d
FOLDER_ICON_SMALL	finder.c	212;"	d	file:
FRONT_DAC_RATE	sound.c	30;"	d	file:
File_Node	drawingAPI.h	/^struct File_Node$/;"	s
GDBPORT	Makefile	/^GDBPORT = $(shell expr `id -u` % 5000 + 25000)$/;"	m
GUILIB	Makefile	/^GUILIB = context.o drawingAPI.o bitmap.o clickable.o math.o common.o huffman.o decodemp3.o$/;"	m
HANKAKU	drawingAPI.h	4;"	d
HAN_SIZE	common.h	30;"	d
HOURS	lapic.c	180;"	d	file:
HTN	huffman.h	7;"	d
HUFFBITS	huffman.h	6;"	d
HZK16	drawingAPI.h	9;"	d
Handler	.asm	/^Handler wndEvents[] = { h_closeWnd, h_empty, h_chvm2, h_chvm1, h_newFolder,$/;"	l
Handler	clickable.h	/^typedef void(*Handler)(Point);$/;"	t
Header	umalloc.c	/^typedef union header Header;$/;"	t	typeref:union:header	file:
IBLOCK	fs.h	40;"	d
ICON	drawingAPI.h	/^} ICON;$/;"	t	typeref:struct:Icon
ICON_HEIGHT_BIG	finder.c	44;"	d	file:
ICON_HEIGHT_SMALL	finder.c	47;"	d	file:
ICON_ITEM_GAP_X	finder.c	28;"	d	file:
ICON_ITEM_GAP_Y	finder.c	29;"	d	file:
ICON_ITEM_HEIGHT	finder.c	27;"	d	file:
ICON_ITEM_OFFSET_X	finder.c	30;"	d	file:
ICON_ITEM_OFFSET_Y	finder.c	31;"	d	file:
ICON_ITEM_WIDTH	finder.c	26;"	d	file:
ICON_STYLE	finder.c	23;"	d	file:
ICON_WIDTH_BIG	finder.c	43;"	d	file:
ICON_WIDTH_SMALL	finder.c	46;"	d	file:
ICRHI	lapic.c	30;"	d	file:
ICRLO	lapic.c	20;"	d	file:
ID	lapic.c	13;"	d	file:
IDE_BSY	ide.c	14;"	d	file:
IDE_CMD_READ	ide.c	19;"	d	file:
IDE_CMD_WRITE	ide.c	20;"	d	file:
IDE_DF	ide.c	16;"	d	file:
IDE_DRDY	ide.c	15;"	d	file:
IDE_ERR	ide.c	17;"	d	file:
III_antialias	decodemp3.c	/^void III_antialias(double xr[SBLIMIT][SSLIMIT], double hybridIn[SBLIMIT][SSLIMIT], struct gr_info_s *gr_info, struct frame_params *fr_ps)$/;"	f
III_dequantize_sample	decodemp3.c	/^void III_dequantize_sample(long int is[SBLIMIT][SSLIMIT], double xr[SBLIMIT][SSLIMIT], III_scalefac_t *scalefac, struct gr_info_s *gr_info, int ch, struct frame_params *fr_ps)$/;"	f
III_get_scale_factors	decodemp3.c	/^void III_get_scale_factors(III_scalefac_t *scalefac, struct III_side_info_t *si, int gr, int ch, struct frame_params *fr_ps)$/;"	f
III_get_side_info	decodemp3.c	/^void III_get_side_info(Bit_stream_struc *bs, struct III_side_info_t *si, struct frame_params *fr_ps)$/;"	f
III_hufman_decode	decodemp3.c	/^void III_hufman_decode(long int is[SBLIMIT][SSLIMIT], struct III_side_info_t *si, int ch, int gr, int part2_start, struct frame_params *fr_ps)$/;"	f
III_hybrid	decodemp3.c	/^void III_hybrid(double fsIn[SSLIMIT], double tsOut[SSLIMIT], int sb, int ch, struct gr_info_s *gr_info, struct frame_params *fr_ps)$/;"	f
III_reorder	decodemp3.c	/^void III_reorder(double xr[SBLIMIT][SSLIMIT], double ro[SBLIMIT][SSLIMIT], struct gr_info_s *gr_info, struct frame_params *fr_ps)$/;"	f
III_scalefac_t	common.h	/^} III_scalefac_t[2];	\/* [ch] *\/$/;"	t	typeref:struct:__anon15
III_side_info	sound.h	/^	struct III_side_info_t III_side_info; $/;"	m	struct:coreBuf	typeref:struct:coreBuf::III_side_info_t
III_side_info_t	common.h	/^struct III_side_info_t {$/;"	s
III_stereo	decodemp3.c	/^void III_stereo(double xr[2][SBLIMIT][SSLIMIT], double lr[2][SBLIMIT][SSLIMIT], III_scalefac_t *scalefac, struct gr_info_s *gr_info, struct frame_params *fr_ps)$/;"	f
INIT	lapic.c	21;"	d	file:
INPUT_BUF	console.c	34;"	d	file:
INT_ACTIVELOW	ioapic.c	22;"	d	file:
INT_DISABLED	ioapic.c	20;"	d	file:
INT_LEVEL	ioapic.c	21;"	d	file:
INT_LOGICAL	ioapic.c	23;"	d	file:
IOAPIC	ioapic.c	9;"	d	file:
IO_PIC1	picirq.c	8;"	d	file:
IO_PIC2	picirq.c	9;"	d	file:
IO_TIMER1	timer.c	10;"	d	file:
IPB	fs.h	37;"	d
IRQ_COM1	traps.h	34;"	d
IRQ_ERROR	traps.h	38;"	d
IRQ_IDE	traps.h	37;"	d
IRQ_KBD	traps.h	33;"	d
IRQ_MOUS	traps.h	36;"	d
IRQ_SLAVE	picirq.c	11;"	d	file:
IRQ_SOUND	traps.h	35;"	d
IRQ_SPURIOUS	traps.h	39;"	d
IRQ_TIMER	traps.h	32;"	d
I_BUSY	file.h	26;"	d
I_VALID	file.h	27;"	d
Icon	drawingAPI.h	/^typedef struct Icon {$/;"	s
KBDATAP	kbd.h	5;"	d
KBSTATP	kbd.h	3;"	d
KBS_DIB	kbd.h	4;"	d
KERNBASE	memlayout.h	8;"	d
KERNLINK	memlayout.h	9;"	d
KEY_DEL	kbd.h	29;"	d
KEY_DN	kbd.h	23;"	d
KEY_END	kbd.h	21;"	d
KEY_HOME	kbd.h	20;"	d
KEY_INS	kbd.h	28;"	d
KEY_LF	kbd.h	24;"	d
KEY_PGDN	kbd.h	27;"	d
KEY_PGUP	kbd.h	26;"	d
KEY_RT	kbd.h	25;"	d
KEY_UP	kbd.h	22;"	d
KSTACKSIZE	param.h	2;"	d
LD	Makefile	/^LD = $(TOOLPREFIX)ld$/;"	m
LEFT_CLICK	mouse.h	2;"	d
LEVEL	lapic.c	26;"	d	file:
LFE_DAC_RATE	sound.c	32;"	d	file:
LINT0	lapic.c	35;"	d	file:
LINT1	lapic.c	36;"	d	file:
LIST	sh.c	11;"	d	file:
LIST_ITEM_FILENAME	finder.c	37;"	d	file:
LIST_ITEM_GAP	finder.c	34;"	d	file:
LIST_ITEM_HEIGHT	finder.c	33;"	d	file:
LIST_ITEM_OFFSET_X	finder.c	35;"	d	file:
LIST_ITEM_OFFSET_Y	finder.c	36;"	d	file:
LIST_ITEM_SIZE	finder.c	38;"	d	file:
LIST_STYLE	finder.c	24;"	d	file:
LOGSIZE	param.h	11;"	d
LONG	bitmap.h	/^typedef long LONG;$/;"	t
MASKED	lapic.c	38;"	d	file:
MATH_H	math.h	2;"	d
MAX	window.h	14;"	d
MAXARG	param.h	9;"	d
MAXARGS	sh.c	14;"	d	file:
MAXCOUNT	cal.c	7;"	d	file:
MAXFILE	fs.h	24;"	d
MAXNUM	cal.c	8;"	d	file:
MAXOPBLOCKS	param.h	10;"	d
MAXWINDOW	window.c	4;"	d	file:
MAX_LENGTH	common.h	17;"	d
MAX_LINE_LENGTH	editor.c	9;"	d	file:
MAX_LINE_NUMBER	editor.c	8;"	d	file:
MAX_PROCESS_NUMBER	message.h	11;"	d
MAX_QUEUE_LENGTH	message.h	12;"	d
MC_BDBAR	sound.c	37;"	d	file:
MC_CR	sound.c	40;"	d	file:
MC_LVI	sound.c	38;"	d	file:
MC_SR	sound.c	39;"	d	file:
MEMFSOBJS	Makefile	/^MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o$/;"	m
MIN	common.h	25;"	d
MIN	window.h	13;"	d
MINIMUM	common.h	16;"	d
MINS	lapic.c	179;"	d	file:
MONTH	lapic.c	182;"	d	file:
MPBOOT	mp.h	34;"	d
MPBUS	mp.h	50;"	d
MPG_MD_DUAL_CHANNEL	common.h	8;"	d
MPG_MD_JOINT_STEREO	common.h	7;"	d
MPG_MD_MONO	common.h	9;"	d
MPG_MD_STEREO	common.h	6;"	d
MPIOAPIC	mp.h	51;"	d
MPIOINTR	mp.h	52;"	d
MPLINTR	mp.h	53;"	d
MPPROC	mp.h	49;"	d
MSG_DOUBLECLICK	message.h	6;"	d
MSG_DRAG	message.h	7;"	d
MSG_KEYDOWN	message.h	8;"	d
MSG_LPRESS	message.h	4;"	d
MSG_MOVE	message.h	3;"	d
MSG_NONE	message.h	1;"	d
MSG_PARTIAL_UPDATE	message.h	10;"	d
MSG_RPRESS	message.h	5;"	d
MSG_UNUSED	message.h	2;"	d
MSG_UPDATE	message.h	9;"	d
MXOFF	huffman.h	8;"	d
Msg	message.h	/^typedef struct Msg$/;"	s
Msg	message.h	/^} Msg;$/;"	t	typeref:struct:Msg
MsgKey	message.h	/^typedef struct MsgKey$/;"	s
MsgKey	message.h	/^} MsgKey;$/;"	t	typeref:struct:MsgKey
MsgMouse	message.h	/^typedef struct MsgMouse$/;"	s
MsgMouse	message.h	/^} MsgMouse;$/;"	t	typeref:struct:MsgMouse
MsgPartialUpdate	message.h	/^typedef struct MsgPartialUpdate $/;"	s
MsgPartialUpdate	message.h	/^} MsgPartialUpdate;$/;"	t	typeref:struct:MsgPartialUpdate
MsgQueue	message.c	/^struct Msg MsgQueue[MAX_QUEUE_LENGTH];$/;"	v	typeref:struct:Msg
MsgTable	message.c	/^struct MsgTableEntry MsgTable[MAX_PROCESS_NUMBER];$/;"	v	typeref:struct:MsgTableEntry
MsgTableEntry	message.h	/^typedef struct MsgTableEntry$/;"	s
MsgTableEntry	message.h	/^} MsgTableEntry;$/;"	t	typeref:struct:MsgTableEntry
N	forktest.asm	/^#define N  1000$/;"	d
N	forktest.c	8;"	d	file:
NABMBA_GLOB_CNT	sound.c	28;"	d	file:
NABMBA_GLOB_STA	sound.c	29;"	d	file:
NAMBA_PCMV	sound.c	23;"	d	file:
NAMBA_PCVID1	sound.c	24;"	d	file:
NAMBA_PCVID2	sound.c	25;"	d	file:
NBUF	param.h	12;"	d
NCPU	param.h	3;"	d
NDEV	param.h	7;"	d
NDIRECT	fs.h	22;"	d
NELEM	defs.h	234;"	d
NFILE	param.h	5;"	d
NINDIRECT	fs.h	23;"	d
NINODE	param.h	6;"	d
NO	kbd.h	7;"	d
NOFILE	param.h	4;"	d
NPDENTRIES	mmu.h	121;"	d
NPROC	param.h	1;"	d
NPTENTRIES	mmu.h	122;"	d
NSEGS	proc.h	2;"	d
NULL	editor.c	10;"	d	file:
NUMLOCK	kbd.h	14;"	d
OBJCOPY	Makefile	/^OBJCOPY = $(TOOLPREFIX)objcopy$/;"	m
OBJDUMP	Makefile	/^OBJDUMP = $(TOOLPREFIX)objdump$/;"	m
OBJS	Makefile	/^OBJS = \\$/;"	m
O_CREATE	fcntl.h	4;"	d
O_RDONLY	fcntl.h	1;"	d
O_RDWR	fcntl.h	3;"	d
O_WRONLY	fcntl.h	2;"	d
OpenTableFile	common.c	/^int OpenTableFile(char *name)$/;"	f
P2V	memlayout.h	19;"	d
P2V_WO	memlayout.h	22;"	d
PCINT	lapic.c	34;"	d	file:
PCI_CONFIG_SPACE_INTRL	sound.c	20;"	d	file:
PCI_CONFIG_SPACE_NABMBA	sound.c	18;"	d	file:
PCI_CONFIG_SPACE_NAMBA	sound.c	17;"	d	file:
PCI_CONFIG_SPACE_SID_SVID	sound.c	19;"	d	file:
PCI_CONFIG_SPACE_STA_CMD	sound.c	16;"	d	file:
PCM_IN	sound.h	47;"	d
PCM_OUT	sound.h	46;"	d
PDX	mmu.h	112;"	d
PDXSHIFT	mmu.h	127;"	d
PERIODIC	lapic.c	33;"	d	file:
PGADDR	mmu.h	118;"	d
PGROUNDDOWN	mmu.h	130;"	d
PGROUNDUP	mmu.h	129;"	d
PGSHIFT	mmu.h	125;"	d
PGSIZE	mmu.h	123;"	d
PHYSTOP	memlayout.h	4;"	d
PI	common.h	33;"	d
PI4	common.h	35;"	d
PI64	common.h	34;"	d
PICNODE	bitmap.h	/^} PICNODE;$/;"	t	typeref:struct:PicNode
PIPE	sh.c	10;"	d	file:
PIPESIZE	pipe.c	10;"	d	file:
PO_BDBAR	sound.c	33;"	d	file:
PO_CR	sound.c	36;"	d	file:
PO_LVI	sound.c	34;"	d	file:
PO_SR	sound.c	35;"	d	file:
PRINT	Makefile	/^PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)$/;"	m
PROCESSED	sound.h	45;"	d
PTE_A	mmu.h	138;"	d
PTE_ADDR	mmu.h	144;"	d
PTE_D	mmu.h	139;"	d
PTE_FLAGS	mmu.h	145;"	d
PTE_MBZ	mmu.h	141;"	d
PTE_P	mmu.h	133;"	d
PTE_PCD	mmu.h	137;"	d
PTE_PS	mmu.h	140;"	d
PTE_PWT	mmu.h	136;"	d
PTE_U	mmu.h	135;"	d
PTE_W	mmu.h	134;"	d
PTX	mmu.h	115;"	d
PTXSHIFT	mmu.h	126;"	d
PicNode	bitmap.h	/^typedef struct PicNode {$/;"	s
Point	.asm	/^Point initPoint(int x, int y)$/;"	l
Point	clickable.h	/^typedef struct Point$/;"	s
Point	clickable.h	/^} Point;$/;"	t	typeref:struct:Point
QEMU	Makefile	/^QEMU = $(shell if which qemu > \/dev\/null; \\$/;"	m
QEMUGDB	Makefile	/^QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \\$/;"	m
QEMUOPTS	Makefile	/^QEMUOPTS = -soundhw ac97 -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)$/;"	m
READ_MODE	common.h	20;"	d
REDIR	sh.c	9;"	d	file:
REG_ID	ioapic.c	11;"	d	file:
REG_TABLE	ioapic.c	13;"	d	file:
REG_VER	ioapic.c	12;"	d	file:
RGBQUAD	bitmap.h	/^} RGBQUAD;$/;"	t	typeref:struct:tagRGBQUAD
RIGHT_CLICK	mouse.h	3;"	d
ROOTDEV	param.h	8;"	d
ROOTINO	fs.h	11;"	d
RUNNABLE	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNING	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
Rect	.asm	/^Rect getPos(Context context, int n) {$/;"	l
Rect	.asm	/^Rect initRect(int x, int y, int w, int h)$/;"	l
Rect	clickable.h	/^typedef struct Rect$/;"	s
Rect	clickable.h	/^} Rect;$/;"	t	typeref:struct:Rect
Rect	window.h	/^typedef struct Rect$/;"	s
Rect	window.h	/^}Rect;$/;"	t	typeref:struct:Rect
SBLIMIT	common.h	27;"	d
SCALE	common.h	31;"	d
SCREEN_HEIGHT	vegamode.h	/^unsigned short SCREEN_HEIGHT;$/;"	v
SCREEN_HEIGHT	vesamode.h	/^unsigned short SCREEN_HEIGHT;$/;"	v
SCREEN_PHYSADDR	vegamode.h	/^unsigned short* SCREEN_PHYSADDR;$/;"	v
SCREEN_PHYSADDR	vesamode.h	/^unsigned short* SCREEN_PHYSADDR;$/;"	v
SCREEN_WIDTH	vegamode.h	/^unsigned short SCREEN_WIDTH;$/;"	v
SCREEN_WIDTH	vesamode.h	/^unsigned short SCREEN_WIDTH;$/;"	v
SCROLLLOCK	kbd.h	15;"	d
SECS	lapic.c	178;"	d	file:
SECTSIZE	bootmain.c	13;"	d	file:
SEG	mmu.h	69;"	d
SEG16	mmu.h	73;"	d
SEG_ASM	asm.h	11;"	d
SEG_KCODE	mmu.h	42;"	d
SEG_KCPU	mmu.h	44;"	d
SEG_KDATA	mmu.h	43;"	d
SEG_NULLASM	asm.h	5;"	d
SEG_TSS	mmu.h	47;"	d
SEG_UCODE	mmu.h	45;"	d
SEG_UDATA	mmu.h	46;"	d
SETGATE	mmu.h	213;"	d
SHIFT	kbd.h	9;"	d
SINGLE_BUF_SIZE	play.asm	/^#define SINGLE_BUF_SIZE 8192$/;"	d
SINGLE_BUF_SIZE	play.c	7;"	d	file:
SIZE_X_MOUSE	window.h	10;"	d
SIZE_Y_MOUSE	window.h	11;"	d
SLEEPING	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
SOUND_NABMBA_DATA	sound.c	/^ushort SOUND_NABMBA_DATA;$/;"	v
SOUND_NAMBA_DATA	sound.c	/^ushort SOUND_NAMBA_DATA;$/;"	v
SSLIMIT	common.h	28;"	d
STARTUP	lapic.c	22;"	d	file:
STA_A	asm.h	21;"	d
STA_A	mmu.h	87;"	d
STA_C	asm.h	18;"	d
STA_C	mmu.h	84;"	d
STA_E	asm.h	17;"	d
STA_E	mmu.h	83;"	d
STA_R	asm.h	20;"	d
STA_R	mmu.h	86;"	d
STA_W	asm.h	19;"	d
STA_W	mmu.h	85;"	d
STA_X	asm.h	16;"	d
STA_X	mmu.h	82;"	d
STS_CG16	mmu.h	93;"	d
STS_CG32	mmu.h	99;"	d
STS_IG16	mmu.h	95;"	d
STS_IG32	mmu.h	100;"	d
STS_LDT	mmu.h	91;"	d
STS_T16A	mmu.h	90;"	d
STS_T16B	mmu.h	92;"	d
STS_T32A	mmu.h	97;"	d
STS_T32B	mmu.h	98;"	d
STS_TG	mmu.h	94;"	d
STS_TG16	mmu.h	96;"	d
STS_TG32	mmu.h	101;"	d
SURROUND_DAC_RATE	sound.c	31;"	d	file:
SVR	lapic.c	17;"	d	file:
SYNC_WORD	common.h	11;"	d
SYNC_WORD_LENGTH	common.h	12;"	d
SYSCALL	usys.S	/^#define SYSCALL(name) \\$/;"	d
SYS_beginDecode	syscall.h	32;"	d
SYS_chdir	syscall.h	10;"	d
SYS_close	syscall.h	22;"	d
SYS_createWindow	syscall.h	24;"	d
SYS_destroyWindow	syscall.h	25;"	d
SYS_dup	syscall.h	11;"	d
SYS_endDecode	syscall.h	34;"	d
SYS_exec	syscall.h	8;"	d
SYS_exit	syscall.h	3;"	d
SYS_fork	syscall.h	2;"	d
SYS_fstat	syscall.h	9;"	d
SYS_getCoreBuf	syscall.h	35;"	d
SYS_getMsg	syscall.h	23;"	d
SYS_getpid	syscall.h	12;"	d
SYS_kill	syscall.h	7;"	d
SYS_kwrite	syscall.h	29;"	d
SYS_link	syscall.h	20;"	d
SYS_mkdir	syscall.h	21;"	d
SYS_mknod	syscall.h	18;"	d
SYS_open	syscall.h	16;"	d
SYS_pause	syscall.h	30;"	d
SYS_pipe	syscall.h	5;"	d
SYS_read	syscall.h	6;"	d
SYS_sbrk	syscall.h	13;"	d
SYS_setSampleRate	syscall.h	28;"	d
SYS_sleep	syscall.h	14;"	d
SYS_unlink	syscall.h	19;"	d
SYS_updatePartialWindow	syscall.h	27;"	d
SYS_updateWindow	syscall.h	26;"	d
SYS_uptime	syscall.h	15;"	d
SYS_wait	syscall.h	4;"	d
SYS_waitForDecode	syscall.h	33;"	d
SYS_wavdecode	syscall.h	31;"	d
SYS_write	syscall.h	17;"	d
SubBandSynthesis	decodemp3.c	/^int SubBandSynthesis (double *bandPtr, int channel, short *samples)$/;"	f
TAGBAR_COLOR	finder.c	41;"	d	file:
TAGBAR_HEIGHT	finder.c	40;"	d	file:
TCCR	lapic.c	40;"	d	file:
TDCR	lapic.c	41;"	d	file:
TICR	lapic.c	39;"	d	file:
TIMER	lapic.c	31;"	d	file:
TIMER_16BIT	timer.c	22;"	d	file:
TIMER_DIV	timer.c	17;"	d	file:
TIMER_FREQ	timer.c	16;"	d	file:
TIMER_MODE	timer.c	19;"	d	file:
TIMER_RATEGEN	timer.c	21;"	d	file:
TIMER_SEL0	timer.c	20;"	d	file:
TITLE_COLOR	windowStyle.h	10;"	d
TITLE_OFFSET_X	windowStyle.h	8;"	d
TITLE_OFFSET_Y	windowStyle.h	9;"	d
TOOLPREFIX	Makefile	/^TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >\/dev\/null 2>&1; \\$/;"	m
TOOLSBAR_COLOR	finder.c	20;"	d	file:
TOOLSBAR_COLOR	finder.h	1;"	d
TOOLSBAR_HEIGHT	finder.c	21;"	d	file:
TOOLSBAR_HEIGHT	finder.h	2;"	d
TOPBAR_COLOR	windowStyle.h	4;"	d
TOPBAR_HEIGHT	windowStyle.h	5;"	d
TPR	lapic.c	15;"	d	file:
TRUE	common.h	23;"	d
T_ALIGN	traps.h	21;"	d
T_BOUND	traps.h	9;"	d
T_BRKPT	traps.h	7;"	d
T_DBLFLT	traps.h	12;"	d
T_DEBUG	traps.h	5;"	d
T_DEFAULT	traps.h	28;"	d
T_DEV	stat.h	3;"	d
T_DEVICE	traps.h	11;"	d
T_DIR	stat.h	1;"	d
T_DIVIDE	traps.h	4;"	d
T_FILE	stat.h	2;"	d
T_FPERR	traps.h	20;"	d
T_GPFLT	traps.h	17;"	d
T_ILLOP	traps.h	10;"	d
T_IRQ0	traps.h	30;"	d
T_MCHK	traps.h	22;"	d
T_NMI	traps.h	6;"	d
T_OFLOW	traps.h	8;"	d
T_PGFLT	traps.h	18;"	d
T_SEGNP	traps.h	15;"	d
T_SIMDERR	traps.h	23;"	d
T_STACK	traps.h	16;"	d
T_SYSCALL	traps.h	27;"	d
T_TSS	traps.h	14;"	d
ULIB	Makefile	/^ULIB = ulib.o usys.o printf.o umalloc.o$/;"	m
UNUSED	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
UPROGS	Makefile	/^UPROGS=\\$/;"	m
V2P	memlayout.h	18;"	d
V2P_WO	memlayout.h	21;"	d
VER	lapic.c	14;"	d	file:
VESA_ADDR	vesamode.h	/^unsigned short* VESA_ADDR;$/;"	v
WIDTHBYTES	bitmap.h	4;"	d
WINDOWSTYLE_H	windowStyle.h	2;"	d
WINDOW_H	window.h	2;"	d
WINDOW_HEIGHT	finder.c	15;"	d	file:
WINDOW_WIDTH	finder.c	14;"	d	file:
WORD	bitmap.h	/^typedef unsigned short WORD;$/;"	t
Window	window.h	/^typedef struct Window$/;"	s
Window	window.h	/^}Window;$/;"	t	typeref:struct:Window
WindowLink	window.h	/^typedef Window* WindowLink;\/\/用队列中的先后顺序表示窗口堆叠的次序$/;"	t
WriteHdr	common.c	/^void WriteHdr(struct frame_params *fr_ps)$/;"	f
X1	lapic.c	32;"	d	file:
YEAR	lapic.c	183;"	d	file:
ZOMBIE	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
_COMMON_H_	common.h	2;"	d
_DECODE_H_	decode.h	2;"	d
_RGB16BIT565	drawingAPI.c	/^int _RGB16BIT565(int r,int g,int b){$/;"	f
_cat	cat.asm	/^_cat:     file format elf32-i386$/;"	l
_decode	decode.asm	/^_decode:     file format elf32-i386$/;"	l
_echo	echo.asm	/^_echo:     file format elf32-i386$/;"	l
_finder	.asm	/^_finder:     file format elf32-i386$/;"	l
_forktest	forktest.asm	/^_forktest:     file format elf32-i386$/;"	l
_grep	grep.asm	/^_grep:     file format elf32-i386$/;"	l
_init	init.asm	/^_init:     file format elf32-i386$/;"	l
_kill	kill.asm	/^_kill:     file format elf32-i386$/;"	l
_ln	ln.asm	/^_ln:     file format elf32-i386$/;"	l
_ls	ls.asm	/^_ls:     file format elf32-i386$/;"	l
_mkdir	mkdir.asm	/^_mkdir:     file format elf32-i386$/;"	l
_pause	pause.asm	/^_pause:     file format elf32-i386$/;"	l
_play	play.asm	/^_play:     file format elf32-i386$/;"	l
_start	entry.S	/^_start = V2P_WO(entry)$/;"	d
a	ls.asm	/^   a:	89 04 24             	mov    %eax,(%esp)$/;"	l
a0	echo.asm	/^  a0:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a0	grep.asm	/^  a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
a0	ln.asm	/^  a0:	c3                   	ret    $/;"	l
a0	play.asm	/^  a0:	8b 84 24 50 00 01 00 	mov    0x10050(%esp),%eax$/;"	l
a01	grep.asm	/^ a01:	8b 45 f8             	mov    -0x8(%ebp),%eax$/;"	l
a02	.asm	/^     a02:	00 $/;"	l
a02	ls.asm	/^ a02:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
a02	play.asm	/^ a02:	75 07                	jne    a0b <morecore+0x34>$/;"	l
a03	.asm	/^     a03:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)$/;"	l
a04	grep.asm	/^ a04:	8b 10                	mov    (%eax),%edx$/;"	l
a04	play.asm	/^ a04:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
a05	ls.asm	/^ a05:	8b 45 f8             	mov    -0x8(%ebp),%eax$/;"	l
a06	grep.asm	/^ a06:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
a08	ls.asm	/^ a08:	8b 10                	mov    (%eax),%edx$/;"	l
a09	grep.asm	/^ a09:	89 10                	mov    %edx,(%eax)$/;"	l
a09	play.asm	/^ a09:	eb 22                	jmp    a2d <morecore+0x56>$/;"	l
a0a	.asm	/^     a0a:	00 $/;"	l
a0a	ls.asm	/^ a0a:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
a0b	.asm	/^     a0b:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a0b	grep.asm	/^ a0b:	eb 08                	jmp    a15 <free+0xcd>$/;"	l
a0b	play.asm	/^ a0b:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a0d	grep.asm	/^ a0d:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
a0d	ls.asm	/^ a0d:	89 10                	mov    %edx,(%eax)$/;"	l
a0e	.asm	/^     a0e:	89 04 24             	mov    %eax,(%esp)$/;"	l
a0e	play.asm	/^ a0e:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
a0f	ls.asm	/^ a0f:	eb 08                	jmp    a19 <free+0xcd>$/;"	l
a1	kill.asm	/^  a1:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a1	ln.asm	/^  a1:	55                   	push   %ebp$/;"	l
a10	grep.asm	/^ a10:	8b 55 f8             	mov    -0x8(%ebp),%edx$/;"	l
a11	.asm	/^     a11:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
a11	ls.asm	/^ a11:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
a11	play.asm	/^ a11:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a13	grep.asm	/^ a13:	89 10                	mov    %edx,(%eax)$/;"	l
a14	.asm	/^     a14:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a14	ls.asm	/^ a14:	8b 55 f8             	mov    -0x8(%ebp),%edx$/;"	l
a14	play.asm	/^ a14:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
a15	grep.asm	/^ a15:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
a17	ls.asm	/^ a17:	89 10                	mov    %edx,(%eax)$/;"	l
a17	play.asm	/^ a17:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
a18	.asm	/^     a18:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
a18	grep.asm	/^ a18:	a3 88 0e 00 00       	mov    %eax,0xe88$/;"	l
a19	ls.asm	/^ a19:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
a1a	play.asm	/^ a1a:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a1b	.asm	/^     a1b:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
a1c	ls.asm	/^ a1c:	a3 68 0e 00 00       	mov    %eax,0xe68$/;"	l
a1d	grep.asm	/^ a1d:	c9                   	leave  $/;"	l
a1d	play.asm	/^ a1d:	83 c0 08             	add    $0x8,%eax$/;"	l
a1e	grep.asm	/^ a1e:	c3                   	ret    $/;"	l
a1f	.asm	/^     a1f:	e8 a5 14 00 00       	call   1ec9 <fill_rect>$/;"	l
a1f	grep.asm	/^ a1f:	55                   	push   %ebp$/;"	l
a2	.asm	/^      a2:	8b 45 e0             	mov    -0x20(%ebp),%eax$/;"	l
a2	decode.asm	/^  a2:	89 d1                	mov    %edx,%ecx$/;"	l
a2	ln.asm	/^  a2:	89 e5                	mov    %esp,%ebp$/;"	l
a2	mkdir.asm	/^  a2:	89 55 10             	mov    %edx,0x10(%ebp)$/;"	l
a2	pause.asm	/^  a2:	89 d1                	mov    %edx,%ecx$/;"	l
a20	grep.asm	/^ a20:	89 e5                	mov    %esp,%ebp$/;"	l
a20	play.asm	/^ a20:	89 04 24             	mov    %eax,(%esp)$/;"	l
a21	ls.asm	/^ a21:	c9                   	leave  $/;"	l
a22	grep.asm	/^ a22:	83 ec 28             	sub    $0x28,%esp$/;"	l
a22	ls.asm	/^ a22:	c3                   	ret    $/;"	l
a23	ls.asm	/^ a23:	55                   	push   %ebp$/;"	l
a23	play.asm	/^ a23:	e8 d8 fe ff ff       	call   900 <free>$/;"	l
a24	.asm	/^     a24:	c7 44 24 18 03 00 00 	movl   $0x3,0x18(%esp)$/;"	l
a24	ls.asm	/^ a24:	89 e5                	mov    %esp,%ebp$/;"	l
a25	grep.asm	/^ a25:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)$/;"	l
a26	ls.asm	/^ a26:	83 ec 28             	sub    $0x28,%esp$/;"	l
a28	play.asm	/^ a28:	a1 cc 0d 00 00       	mov    0xdcc,%eax$/;"	l
a29	ls.asm	/^ a29:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)$/;"	l
a2b	.asm	/^     a2b:	00 $/;"	l
a2c	.asm	/^     a2c:	c7 44 24 14 2c 01 00 	movl   $0x12c,0x14(%esp)$/;"	l
a2c	grep.asm	/^ a2c:	77 07                	ja     a35 <morecore+0x16>$/;"	l
a2d	play.asm	/^ a2d:	c9                   	leave  $/;"	l
a2e	grep.asm	/^ a2e:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)$/;"	l
a2e	play.asm	/^ a2e:	c3                   	ret    $/;"	l
a2f	play.asm	/^ a2f:	55                   	push   %ebp$/;"	l
a3	echo.asm	/^  a3:	88 10                	mov    %dl,(%eax)$/;"	l
a3	ls.asm	/^  a3:	b8 50 0e 00 00       	mov    $0xe50,%eax$/;"	l
a30	ls.asm	/^ a30:	77 07                	ja     a39 <morecore+0x16>$/;"	l
a30	play.asm	/^ a30:	89 e5                	mov    %esp,%ebp$/;"	l
a32	ls.asm	/^ a32:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)$/;"	l
a32	play.asm	/^ a32:	83 ec 28             	sub    $0x28,%esp$/;"	l
a33	.asm	/^     a33:	00 $/;"	l
a34	.asm	/^     a34:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)$/;"	l
a35	grep.asm	/^ a35:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a35	play.asm	/^ a35:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a38	grep.asm	/^ a38:	c1 e0 03             	shl    $0x3,%eax$/;"	l
a38	play.asm	/^ a38:	83 c0 07             	add    $0x7,%eax$/;"	l
a39	ls.asm	/^ a39:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a3b	.asm	/^     a3b:	00 $/;"	l
a3b	grep.asm	/^ a3b:	89 04 24             	mov    %eax,(%esp)$/;"	l
a3b	play.asm	/^ a3b:	c1 e8 03             	shr    $0x3,%eax$/;"	l
a3c	.asm	/^     a3c:	c7 44 24 0c c4 41 00 	movl   $0x41c4,0xc(%esp)$/;"	l
a3c	ls.asm	/^ a3c:	c1 e0 03             	shl    $0x3,%eax$/;"	l
a3e	grep.asm	/^ a3e:	e8 f9 fb ff ff       	call   63c <sbrk>$/;"	l
a3e	play.asm	/^ a3e:	83 c0 01             	add    $0x1,%eax$/;"	l
a3f	ls.asm	/^ a3f:	89 04 24             	mov    %eax,(%esp)$/;"	l
a4	decode.asm	/^  a4:	29 c1                	sub    %eax,%ecx$/;"	l
a4	forktest.asm	/^  a4:	85 c0                	test   %eax,%eax$/;"	l
a4	grep.asm	/^  a4:	7e 2b                	jle    d1 <grep+0xd1>$/;"	l
a4	init.asm	/^  a4:	e8 43 03 00 00       	call   3ec <exit>$/;"	l
a4	kill.asm	/^  a4:	0f b6 00             	movzbl (%eax),%eax$/;"	l
a4	ln.asm	/^  a4:	83 ec 10             	sub    $0x10,%esp$/;"	l
a4	pause.asm	/^  a4:	29 c1                	sub    %eax,%ecx$/;"	l
a41	play.asm	/^ a41:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
a42	ls.asm	/^ a42:	e8 f9 fb ff ff       	call   640 <sbrk>$/;"	l
a43	.asm	/^     a43:	00 $/;"	l
a43	grep.asm	/^ a43:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
a44	.asm	/^     a44:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a44	play.asm	/^ a44:	a1 cc 0d 00 00       	mov    0xdcc,%eax$/;"	l
a46	grep.asm	/^ a46:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)$/;"	l
a47	.asm	/^     a47:	89 04 24             	mov    %eax,(%esp)$/;"	l
a47	ls.asm	/^ a47:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
a49	play.asm	/^ a49:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
a4a	.asm	/^     a4a:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
a4a	grep.asm	/^ a4a:	75 07                	jne    a53 <morecore+0x34>$/;"	l
a4a	ls.asm	/^ a4a:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)$/;"	l
a4c	grep.asm	/^ a4c:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
a4c	play.asm	/^ a4c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)$/;"	l
a4d	.asm	/^     a4d:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a4e	ls.asm	/^ a4e:	75 07                	jne    a57 <morecore+0x34>$/;"	l
a5	.asm	/^      a5:	89 43 20             	mov    %eax,0x20(%ebx)$/;"	l
a5	cat.asm	/^  a5:	00 $/;"	l
a5	echo.asm	/^  a5:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a5	mkdir.asm	/^  a5:	5b                   	pop    %ebx$/;"	l
a50	ls.asm	/^ a50:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
a50	play.asm	/^ a50:	75 23                	jne    a75 <malloc+0x46>$/;"	l
a51	.asm	/^     a51:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
a51	grep.asm	/^ a51:	eb 22                	jmp    a75 <morecore+0x56>$/;"	l
a52	play.asm	/^ a52:	c7 45 f0 c4 0d 00 00 	movl   $0xdc4,-0x10(%ebp)$/;"	l
a53	grep.asm	/^ a53:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a54	.asm	/^     a54:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
a55	ls.asm	/^ a55:	eb 22                	jmp    a79 <morecore+0x56>$/;"	l
a56	grep.asm	/^ a56:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
a57	ls.asm	/^ a57:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a58	.asm	/^     a58:	e8 6c 1a 00 00       	call   24c9 <puts_str>$/;"	l
a59	grep.asm	/^ a59:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a59	play.asm	/^ a59:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a5a	ls.asm	/^ a5a:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
a5c	grep.asm	/^ a5c:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
a5c	play.asm	/^ a5c:	a3 cc 0d 00 00       	mov    %eax,0xdcc$/;"	l
a5d	.asm	/^     a5d:	c7 44 24 10 08 00 00 	movl   $0x8,0x10(%esp)$/;"	l
a5d	ls.asm	/^ a5d:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a5f	grep.asm	/^ a5f:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
a6	cat.asm	/^  a6:	89 04 24             	mov    %eax,(%esp)$/;"	l
a6	decode.asm	/^  a6:	89 c8                	mov    %ecx,%eax$/;"	l
a6	forktest.asm	/^  a6:	79 19                	jns    c1 <forktest+0x98>$/;"	l
a6	grep.asm	/^  a6:	ba a0 0e 00 00       	mov    $0xea0,%edx$/;"	l
a6	mkdir.asm	/^  a6:	5f                   	pop    %edi$/;"	l
a6	pause.asm	/^  a6:	89 c8                	mov    %ecx,%eax$/;"	l
a60	ls.asm	/^ a60:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
a61	play.asm	/^ a61:	a1 cc 0d 00 00       	mov    0xdcc,%eax$/;"	l
a62	grep.asm	/^ a62:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a63	ls.asm	/^ a63:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
a64	.asm	/^     a64:	00 $/;"	l
a65	.asm	/^     a65:	c7 44 24 0c 60 52 00 	movl   $0x5260,0xc(%esp)$/;"	l
a65	grep.asm	/^ a65:	83 c0 08             	add    $0x8,%eax$/;"	l
a66	ls.asm	/^ a66:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a66	play.asm	/^ a66:	a3 c4 0d 00 00       	mov    %eax,0xdc4$/;"	l
a68	grep.asm	/^ a68:	89 04 24             	mov    %eax,(%esp)$/;"	l
a69	ls.asm	/^ a69:	83 c0 08             	add    $0x8,%eax$/;"	l
a6b	grep.asm	/^ a6b:	e8 d8 fe ff ff       	call   948 <free>$/;"	l
a6b	play.asm	/^ a6b:	c7 05 c8 0d 00 00 00 	movl   $0x0,0xdc8$/;"	l
a6c	.asm	/^     a6c:	00 $/;"	l
a6c	ls.asm	/^ a6c:	89 04 24             	mov    %eax,(%esp)$/;"	l
a6d	.asm	/^     a6d:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a6f	ls.asm	/^ a6f:	e8 d8 fe ff ff       	call   94c <free>$/;"	l
a7	kill.asm	/^  a7:	84 c0                	test   %al,%al$/;"	l
a7	ln.asm	/^  a7:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a7	mkdir.asm	/^  a7:	5d                   	pop    %ebp$/;"	l
a7	play.asm	/^  a7:	89 04 24             	mov    %eax,(%esp)$/;"	l
a70	.asm	/^     a70:	89 04 24             	mov    %eax,(%esp)$/;"	l
a70	grep.asm	/^ a70:	a1 88 0e 00 00       	mov    0xe88,%eax$/;"	l
a72	play.asm	/^ a72:	00 00 00 $/;"	l
a73	.asm	/^     a73:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
a74	ls.asm	/^ a74:	a1 68 0e 00 00       	mov    0xe68,%eax$/;"	l
a75	grep.asm	/^ a75:	c9                   	leave  $/;"	l
a75	play.asm	/^ a75:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a76	.asm	/^     a76:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a76	grep.asm	/^ a76:	c3                   	ret    $/;"	l
a77	grep.asm	/^ a77:	55                   	push   %ebp$/;"	l
a78	grep.asm	/^ a78:	89 e5                	mov    %esp,%ebp$/;"	l
a78	play.asm	/^ a78:	8b 00                	mov    (%eax),%eax$/;"	l
a79	ls.asm	/^ a79:	c9                   	leave  $/;"	l
a7a	.asm	/^     a7a:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
a7a	grep.asm	/^ a7a:	83 ec 28             	sub    $0x28,%esp$/;"	l
a7a	ls.asm	/^ a7a:	c3                   	ret    $/;"	l
a7a	play.asm	/^ a7a:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
a7b	ls.asm	/^ a7b:	55                   	push   %ebp$/;"	l
a7c	ls.asm	/^ a7c:	89 e5                	mov    %esp,%ebp$/;"	l
a7d	.asm	/^     a7d:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
a7d	grep.asm	/^ a7d:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a7d	play.asm	/^ a7d:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a7e	ls.asm	/^ a7e:	83 ec 28             	sub    $0x28,%esp$/;"	l
a8	.asm	/^      a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax$/;"	l
a8	decode.asm	/^  a8:	5d                   	pop    %ebp$/;"	l
a8	echo.asm	/^  a8:	0f b6 00             	movzbl (%eax),%eax$/;"	l
a8	forktest.asm	/^  a8:	c7 44 24 04 ab 04 00 	movl   $0x4ab,0x4(%esp)$/;"	l
a8	ls.asm	/^  a8:	83 c4 24             	add    $0x24,%esp$/;"	l
a8	mkdir.asm	/^  a8:	c3                   	ret    $/;"	l
a8	pause.asm	/^  a8:	5d                   	pop    %ebp$/;"	l
a80	grep.asm	/^ a80:	83 c0 07             	add    $0x7,%eax$/;"	l
a80	play.asm	/^ a80:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a81	.asm	/^     a81:	e8 b8 1f 00 00       	call   2a3e <draw_iconlist>$/;"	l
a81	ls.asm	/^ a81:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a83	grep.asm	/^ a83:	c1 e8 03             	shr    $0x3,%eax$/;"	l
a83	play.asm	/^ a83:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
a84	ls.asm	/^ a84:	83 c0 07             	add    $0x7,%eax$/;"	l
a86	.asm	/^     a86:	c9                   	leave  $/;"	l
a86	grep.asm	/^ a86:	83 c0 01             	add    $0x1,%eax$/;"	l
a86	play.asm	/^ a86:	72 4d                	jb     ad5 <malloc+0xa6>$/;"	l
a87	.asm	/^     a87:	c3                   	ret    $/;"	l
a87	ls.asm	/^ a87:	c1 e8 03             	shr    $0x3,%eax$/;"	l
a88	.asm	/^     a88:	55                   	push   %ebp$/;"	l
a88	play.asm	/^ a88:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a89	.asm	/^     a89:	89 e5                	mov    %esp,%ebp$/;"	l
a89	grep.asm	/^ a89:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
a8a	ls.asm	/^ a8a:	83 c0 01             	add    $0x1,%eax$/;"	l
a8b	.asm	/^     a8b:	83 ec 58             	sub    $0x58,%esp$/;"	l
a8b	play.asm	/^ a8b:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a8c	grep.asm	/^ a8c:	a1 88 0e 00 00       	mov    0xe88,%eax$/;"	l
a8d	ls.asm	/^ a8d:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
a8e	.asm	/^     a8e:	c7 45 f0 46 00 00 00 	movl   $0x46,-0x10(%ebp)$/;"	l
a8e	play.asm	/^ a8e:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
a9	cat.asm	/^  a9:	e8 06 03 00 00       	call   3b4 <open>$/;"	l
a9	decode.asm	/^  a9:	c3                   	ret    $/;"	l
a9	init.asm	/^  a9:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)$/;"	l
a9	kill.asm	/^  a9:	0f 95 c0             	setne  %al$/;"	l
a9	mkdir.asm	/^  a9:	55                   	push   %ebp$/;"	l
a9	pause.asm	/^  a9:	c3                   	ret    $/;"	l
a90	ls.asm	/^ a90:	a1 68 0e 00 00       	mov    0xe68,%eax$/;"	l
a91	grep.asm	/^ a91:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
a91	play.asm	/^ a91:	75 0c                	jne    a9f <malloc+0x70>$/;"	l
a93	play.asm	/^ a93:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a94	grep.asm	/^ a94:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)$/;"	l
a95	.asm	/^     a95:	a1 64 51 00 00       	mov    0x5164,%eax$/;"	l
a95	ls.asm	/^ a95:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
a96	play.asm	/^ a96:	8b 10                	mov    (%eax),%edx$/;"	l
a98	grep.asm	/^ a98:	75 23                	jne    abd <malloc+0x46>$/;"	l
a98	ls.asm	/^ a98:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)$/;"	l
a98	play.asm	/^ a98:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a9a	.asm	/^     a9a:	83 f8 02             	cmp    $0x2,%eax$/;"	l
a9a	grep.asm	/^ a9a:	c7 45 f0 80 0e 00 00 	movl   $0xe80,-0x10(%ebp)$/;"	l
a9b	play.asm	/^ a9b:	89 10                	mov    %edx,(%eax)$/;"	l
a9c	ls.asm	/^ a9c:	75 23                	jne    ac1 <malloc+0x46>$/;"	l
a9d	.asm	/^     a9d:	75 04                	jne    aa3 <drawFinderContent+0x1b>$/;"	l
a9d	play.asm	/^ a9d:	eb 26                	jmp    ac5 <malloc+0x96>$/;"	l
a9e	ls.asm	/^ a9e:	c7 45 f0 60 0e 00 00 	movl   $0xe60,-0x10(%ebp)$/;"	l
a9f	.asm	/^     a9f:	83 45 f0 1c          	addl   $0x1c,-0x10(%ebp)$/;"	l
a9f	play.asm	/^ a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
aa	decode.asm	/^  aa:	55                   	push   %ebp$/;"	l
aa	ln.asm	/^  aa:	89 45 fc             	mov    %eax,-0x4(%ebp)$/;"	l
aa	mkdir.asm	/^  aa:	89 e5                	mov    %esp,%ebp$/;"	l
aa	pause.asm	/^  aa:	55                   	push   %ebp$/;"	l
aa	play.asm	/^  aa:	e8 e5 04 00 00       	call   594 <close>$/;"	l
aa1	grep.asm	/^ aa1:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
aa2	play.asm	/^ aa2:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
aa3	.asm	/^     aa3:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
aa4	grep.asm	/^ aa4:	a3 88 0e 00 00       	mov    %eax,0xe88$/;"	l
aa5	ls.asm	/^ aa5:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
aa5	play.asm	/^ aa5:	89 c2                	mov    %eax,%edx$/;"	l
aa6	.asm	/^     aa6:	83 e8 48             	sub    $0x48,%eax$/;"	l
aa7	play.asm	/^ aa7:	2b 55 ec             	sub    -0x14(%ebp),%edx$/;"	l
aa8	ls.asm	/^ aa8:	a3 68 0e 00 00       	mov    %eax,0xe68$/;"	l
aa9	.asm	/^     aa9:	89 c1                	mov    %eax,%ecx$/;"	l
aa9	grep.asm	/^ aa9:	a1 88 0e 00 00       	mov    0xe88,%eax$/;"	l
aaa	play.asm	/^ aaa:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
aab	.asm	/^     aab:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
aad	ls.asm	/^ aad:	a1 68 0e 00 00       	mov    0xe68,%eax$/;"	l
aad	play.asm	/^ aad:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
aae	.asm	/^     aae:	83 e8 02             	sub    $0x2,%eax$/;"	l
aae	grep.asm	/^ aae:	a3 80 0e 00 00       	mov    %eax,0xe80$/;"	l
ab	.asm	/^      ab:	89 43 24             	mov    %eax,0x24(%ebx)$/;"	l
ab	decode.asm	/^  ab:	89 e5                	mov    %esp,%ebp$/;"	l
ab	echo.asm	/^  ab:	84 c0                	test   %al,%al$/;"	l
ab	grep.asm	/^  ab:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ab	ls.asm	/^  ab:	5b                   	pop    %ebx$/;"	l
ab	pause.asm	/^  ab:	89 e5                	mov    %esp,%ebp$/;"	l
ab0	play.asm	/^ ab0:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ab1	.asm	/^     ab1:	89 c2                	mov    %eax,%edx$/;"	l
ab2	ls.asm	/^ ab2:	a3 60 0e 00 00       	mov    %eax,0xe60$/;"	l
ab3	.asm	/^     ab3:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ab3	grep.asm	/^ ab3:	c7 05 84 0e 00 00 00 	movl   $0x0,0xe84$/;"	l
ab3	play.asm	/^ ab3:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
ab6	.asm	/^     ab6:	c7 44 24 1c ff ff 00 	movl   $0xffff,0x1c(%esp)$/;"	l
ab6	play.asm	/^ ab6:	c1 e0 03             	shl    $0x3,%eax$/;"	l
ab7	ls.asm	/^ ab7:	c7 05 64 0e 00 00 00 	movl   $0x0,0xe64$/;"	l
ab9	play.asm	/^ ab9:	01 45 f4             	add    %eax,-0xc(%ebp)$/;"	l
aba	grep.asm	/^ aba:	00 00 00 $/;"	l
abc	play.asm	/^ abc:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
abd	.asm	/^     abd:	00 $/;"	l
abd	grep.asm	/^ abd:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
abe	.asm	/^     abe:	89 4c 24 18          	mov    %ecx,0x18(%esp)$/;"	l
abe	ls.asm	/^ abe:	00 00 00 $/;"	l
abf	play.asm	/^ abf:	8b 55 ec             	mov    -0x14(%ebp),%edx$/;"	l
abs	math.c	/^int abs(int x)$/;"	f
ac	kill.asm	/^  ac:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
ac	ls.asm	/^  ac:	5d                   	pop    %ebp$/;"	l
ac	mkdir.asm	/^  ac:	83 ec 10             	sub    $0x10,%esp$/;"	l
ac0	grep.asm	/^ ac0:	8b 00                	mov    (%eax),%eax$/;"	l
ac1	ls.asm	/^ ac1:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ac2	.asm	/^     ac2:	89 54 24 14          	mov    %edx,0x14(%esp)$/;"	l
ac2	grep.asm	/^ ac2:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
ac2	play.asm	/^ ac2:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
ac4	ls.asm	/^ ac4:	8b 00                	mov    (%eax),%eax$/;"	l
ac5	grep.asm	/^ ac5:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ac5	play.asm	/^ ac5:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ac6	.asm	/^     ac6:	89 44 24 10          	mov    %eax,0x10(%esp)$/;"	l
ac6	ls.asm	/^ ac6:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
ac8	grep.asm	/^ ac8:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
ac8	play.asm	/^ ac8:	a3 cc 0d 00 00       	mov    %eax,0xdcc$/;"	l
ac9	ls.asm	/^ ac9:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
aca	.asm	/^     aca:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)$/;"	l
acb	grep.asm	/^ acb:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
acc	ls.asm	/^ acc:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
acd	play.asm	/^ acd:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ace	grep.asm	/^ ace:	72 4d                	jb     b1d <malloc+0xa6>$/;"	l
acf	ls.asm	/^ acf:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
acquire	spinlock.c	/^acquire(struct spinlock *lk)$/;"	f
activated_window	window.c	/^WindowLink activated_window = 0;$/;"	v
actual_mode	common.h	/^    int         actual_mode;    \/* when writing IS, may forget if 0 chs *\/$/;"	m	struct:frame_params
ad	decode.asm	/^  ad:	83 ec 10             	sub    $0x10,%esp$/;"	l
ad	echo.asm	/^  ad:	0f 95 c0             	setne  %al$/;"	l
ad	ln.asm	/^  ad:	90                   	nop$/;"	l
ad	ls.asm	/^  ad:	c3                   	ret    $/;"	l
ad	pause.asm	/^  ad:	83 ec 10             	sub    $0x10,%esp$/;"	l
ad0	grep.asm	/^ ad0:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ad0	play.asm	/^ ad0:	83 c0 08             	add    $0x8,%eax$/;"	l
ad1	.asm	/^     ad1:	00 $/;"	l
ad2	.asm	/^     ad2:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ad2	ls.asm	/^ ad2:	72 4d                	jb     b21 <malloc+0xa6>$/;"	l
ad3	grep.asm	/^ ad3:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
ad3	play.asm	/^ ad3:	eb 38                	jmp    b0d <malloc+0xde>$/;"	l
ad4	ls.asm	/^ ad4:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ad5	.asm	/^     ad5:	89 04 24             	mov    %eax,(%esp)$/;"	l
ad5	play.asm	/^ ad5:	a1 cc 0d 00 00       	mov    0xdcc,%eax$/;"	l
ad6	grep.asm	/^ ad6:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
ad7	ls.asm	/^ ad7:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
ad8	.asm	/^     ad8:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ad9	grep.asm	/^ ad9:	75 0c                	jne    ae7 <malloc+0x70>$/;"	l
ada	ls.asm	/^ ada:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
ada	play.asm	/^ ada:	39 45 f4             	cmp    %eax,-0xc(%ebp)$/;"	l
adb	.asm	/^     adb:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
adb	grep.asm	/^ adb:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
add	ls.asm	/^ add:	75 0c                	jne    aeb <malloc+0x70>$/;"	l
add	play.asm	/^ add:	75 1b                	jne    afa <malloc+0xcb>$/;"	l
addClickable	clickable.c	/^void addClickable(Clickable **head, Rect r, Handler h)$/;"	f
addFileItem	finder.c	/^void addFileItem(struct stat st, char *name, Rect pos) {$/;"	f
addItemEvent	finder.c	/^void addItemEvent(ClickableManager *cm, struct fileItem item) {$/;"	f
addListEvent	finder.c	/^void addListEvent(ClickableManager *cm) {$/;"	f
addSound	sound.c	/^void addSound(struct soundNode *node)$/;"	f
addWndEvent	finder.c	/^void addWndEvent(ClickableManager *cm) {$/;"	f
addr	context.h	/^	unsigned short *addr;$/;"	m	struct:Context
addr	mp.h	/^  uint *addr;                  \/\/ I\/O APIC address$/;"	m	struct:mpioapic
addrs	file.h	/^  uint addrs[NDIRECT+1];$/;"	m	struct:inode
addrs	fs.h	/^  uint addrs[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:dinode
ade	grep.asm	/^ ade:	8b 10                	mov    (%eax),%edx$/;"	l
adf	.asm	/^     adf:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
adf	ls.asm	/^ adf:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
adf	play.asm	/^ adf:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
ae	.asm	/^      ae:	8b 15 40 54 00 00    	mov    0x5440,%edx$/;"	l
ae	cat.asm	/^  ae:	89 44 24 18          	mov    %eax,0x18(%esp)$/;"	l
ae	grep.asm	/^  ae:	89 d1                	mov    %edx,%ecx$/;"	l
ae	init.asm	/^  ae:	75 2d                	jne    dd <main+0xdd>$/;"	l
ae	ln.asm	/^  ae:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ae	ls.asm	/^  ae:	55                   	push   %ebp$/;"	l
ae0	grep.asm	/^ ae0:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ae2	.asm	/^     ae2:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
ae2	ls.asm	/^ ae2:	8b 10                	mov    (%eax),%edx$/;"	l
ae2	play.asm	/^ ae2:	89 04 24             	mov    %eax,(%esp)$/;"	l
ae3	grep.asm	/^ ae3:	89 10                	mov    %edx,(%eax)$/;"	l
ae4	ls.asm	/^ ae4:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ae5	grep.asm	/^ ae5:	eb 26                	jmp    b0d <malloc+0x96>$/;"	l
ae5	play.asm	/^ ae5:	e8 ed fe ff ff       	call   9d7 <morecore>$/;"	l
ae6	.asm	/^     ae6:	e8 de 13 00 00       	call   1ec9 <fill_rect>$/;"	l
ae7	grep.asm	/^ ae7:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ae7	ls.asm	/^ ae7:	89 10                	mov    %edx,(%eax)$/;"	l
ae9	ls.asm	/^ ae9:	eb 26                	jmp    b11 <malloc+0x96>$/;"	l
aea	grep.asm	/^ aea:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
aea	play.asm	/^ aea:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
aeb	.asm	/^     aeb:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
aeb	ls.asm	/^ aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
aed	grep.asm	/^ aed:	89 c2                	mov    %eax,%edx$/;"	l
aed	play.asm	/^ aed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
aee	.asm	/^     aee:	8d 48 ff             	lea    -0x1(%eax),%ecx$/;"	l
aee	ls.asm	/^ aee:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
aef	grep.asm	/^ aef:	2b 55 ec             	sub    -0x14(%ebp),%edx$/;"	l
af	forktest.asm	/^  af:	00 $/;"	l
af	ls.asm	/^  af:	89 e5                	mov    %esp,%ebp$/;"	l
af	mkdir.asm	/^  af:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
af	play.asm	/^  af:	e8 b8 04 00 00       	call   56c <exit>$/;"	l
af1	.asm	/^     af1:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
af1	ls.asm	/^ af1:	89 c2                	mov    %eax,%edx$/;"	l
af1	play.asm	/^ af1:	75 07                	jne    afa <malloc+0xcb>$/;"	l
af2	grep.asm	/^ af2:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
af3	ls.asm	/^ af3:	2b 55 ec             	sub    -0x14(%ebp),%edx$/;"	l
af3	play.asm	/^ af3:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
af4	.asm	/^     af4:	8d 50 ff             	lea    -0x1(%eax),%edx$/;"	l
af5	grep.asm	/^ af5:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
af6	ls.asm	/^ af6:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
af7	.asm	/^     af7:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
af8	grep.asm	/^ af8:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
af8	play.asm	/^ af8:	eb 13                	jmp    b0d <malloc+0xde>$/;"	l
af9	ls.asm	/^ af9:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
afa	.asm	/^     afa:	83 e8 01             	sub    $0x1,%eax$/;"	l
afa	play.asm	/^ afa:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
afb	grep.asm	/^ afb:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
afc	ls.asm	/^ afc:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
afd	.asm	/^     afd:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)$/;"	l
afd	play.asm	/^ afd:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
afe	grep.asm	/^ afe:	c1 e0 03             	shl    $0x3,%eax$/;"	l
aff	ls.asm	/^ aff:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
align	elf.h	/^  uint align;$/;"	m	struct:proghdr
allocWindow	window.c	/^WindowLink allocWindow(int left_x, int left_y, int right_x, int right_y, int pid)$/;"	f
alloc_buffer	common.c	/^void alloc_buffer(Bit_stream_struc *bs, int size)$/;"	f
allocproc	proc.c	/^allocproc(void)$/;"	f	file:
allocuvm	vm.c	/^allocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f
alltraps	trapasm.S	/^alltraps:$/;"	l
ap	.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	cat.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	decode.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	echo.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	grep.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	init.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	kill.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ln.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ls.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	mkdir.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	pause.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	play.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
apicid	mp.h	/^  uchar apicid;                 \/\/ local APIC id$/;"	m	struct:mpproc
apicno	mp.h	/^  uchar apicno;                 \/\/ I\/O APIC id$/;"	m	struct:mpioapic
area	clickable.h	/^	Rect area;$/;"	m	struct:Clickable
argfd	sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	file:
argint	syscall.c	/^argint(int n, int *ip)$/;"	f
argptr	syscall.c	/^argptr(int n, char **pp, int size)$/;"	f
args	mmu.h	/^  uint args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedesc
argstr	syscall.c	/^argstr(int n, char **pp)$/;"	f
argv	init.c	/^char *argv[] = { "sh", 0 };$/;"	v
argv	initcode.S	/^argv:$/;"	l
argv	sh.c	/^  char *argv[MAXARGS];$/;"	m	struct:execcmd	file:
atoi	ulib.c	/^atoi(const char *s)$/;"	f
audiobuf	sysaudio.c	/^static struct soundNode audiobuf[3];$/;"	v	typeref:struct:soundNode	file:
auto_show	editor.c	/^int auto_show = 1;$/;"	v
avl	mmu.h	/^  uint avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segdesc
b	cat.asm	/^   b:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
b	decode.asm	/^   b:	eb f9                	jmp    6 <main+0x6>$/;"	l
b	pause.asm	/^   b:	e8 64 02 00 00       	call   274 <exit>$/;"	l
b0	decode.asm	/^  b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)$/;"	l
b0	echo.asm	/^  b0:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
b0	forktest.asm	/^  b0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
b0	grep.asm	/^  b0:	29 c1                	sub    %eax,%ecx$/;"	l
b0	init.asm	/^  b0:	c7 44 24 04 9c 0c 00 	movl   $0xc9c,0x4(%esp)$/;"	l
b0	kill.asm	/^  b0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
b0	pause.asm	/^  b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)$/;"	l
b00	play.asm	/^ b00:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b01	grep.asm	/^ b01:	01 45 f4             	add    %eax,-0xc(%ebp)$/;"	l
b02	ls.asm	/^ b02:	c1 e0 03             	shl    $0x3,%eax$/;"	l
b03	play.asm	/^ b03:	8b 00                	mov    (%eax),%eax$/;"	l
b04	.asm	/^     b04:	00 $/;"	l
b04	grep.asm	/^ b04:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b05	.asm	/^     b05:	89 4c 24 18          	mov    %ecx,0x18(%esp)$/;"	l
b05	ls.asm	/^ b05:	01 45 f4             	add    %eax,-0xc(%ebp)$/;"	l
b05	play.asm	/^ b05:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
b07	grep.asm	/^ b07:	8b 55 ec             	mov    -0x14(%ebp),%edx$/;"	l
b08	ls.asm	/^ b08:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b08	play.asm	/^ b08:	e9 70 ff ff ff       	jmp    a7d <malloc+0x4e>$/;"	l
b09	.asm	/^     b09:	89 54 24 14          	mov    %edx,0x14(%esp)$/;"	l
b0a	grep.asm	/^ b0a:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
b0b	ls.asm	/^ b0b:	8b 55 ec             	mov    -0x14(%ebp),%edx$/;"	l
b0d	.asm	/^     b0d:	89 44 24 10          	mov    %eax,0x10(%esp)$/;"	l
b0d	grep.asm	/^ b0d:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
b0d	play.asm	/^ b0d:	c9                   	leave  $/;"	l
b0e	ls.asm	/^ b0e:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
b0e	play.asm	/^ b0e:	c3                   	ret    $/;"	l
b1	ln.asm	/^  b1:	0f b6 10             	movzbl (%eax),%edx$/;"	l
b1	ls.asm	/^  b1:	57                   	push   %edi$/;"	l
b10	grep.asm	/^ b10:	a3 88 0e 00 00       	mov    %eax,0xe88$/;"	l
b11	.asm	/^     b11:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)$/;"	l
b11	ls.asm	/^ b11:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
b14	ls.asm	/^ b14:	a3 68 0e 00 00       	mov    %eax,0xe68$/;"	l
b15	grep.asm	/^ b15:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b18	.asm	/^     b18:	00 $/;"	l
b18	grep.asm	/^ b18:	83 c0 08             	add    $0x8,%eax$/;"	l
b19	.asm	/^     b19:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
b19	ls.asm	/^ b19:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b1b	grep.asm	/^ b1b:	eb 38                	jmp    b55 <malloc+0xde>$/;"	l
b1c	.asm	/^     b1c:	89 04 24             	mov    %eax,(%esp)$/;"	l
b1c	ls.asm	/^ b1c:	83 c0 08             	add    $0x8,%eax$/;"	l
b1d	grep.asm	/^ b1d:	a1 88 0e 00 00       	mov    0xe88,%eax$/;"	l
b1f	.asm	/^     b1f:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
b1f	ls.asm	/^ b1f:	eb 38                	jmp    b59 <malloc+0xde>$/;"	l
b2	cat.asm	/^  b2:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)$/;"	l
b2	grep.asm	/^  b2:	89 c8                	mov    %ecx,%eax$/;"	l
b2	ls.asm	/^  b2:	56                   	push   %esi$/;"	l
b2	mkdir.asm	/^  b2:	89 45 fc             	mov    %eax,-0x4(%ebp)$/;"	l
b21	ls.asm	/^ b21:	a1 68 0e 00 00       	mov    0xe68,%eax$/;"	l
b22	.asm	/^     b22:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
b22	grep.asm	/^ b22:	39 45 f4             	cmp    %eax,-0xc(%ebp)$/;"	l
b25	grep.asm	/^ b25:	75 1b                	jne    b42 <malloc+0xcb>$/;"	l
b26	.asm	/^     b26:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
b26	ls.asm	/^ b26:	39 45 f4             	cmp    %eax,-0xc(%ebp)$/;"	l
b27	grep.asm	/^ b27:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
b29	.asm	/^     b29:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
b29	ls.asm	/^ b29:	75 1b                	jne    b46 <malloc+0xcb>$/;"	l
b2a	grep.asm	/^ b2a:	89 04 24             	mov    %eax,(%esp)$/;"	l
b2b	ls.asm	/^ b2b:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
b2d	.asm	/^     b2d:	e8 24 1b 00 00       	call   2656 <draw_line>$/;"	l
b2d	grep.asm	/^ b2d:	e8 ed fe ff ff       	call   a1f <morecore>$/;"	l
b2e	ls.asm	/^ b2e:	89 04 24             	mov    %eax,(%esp)$/;"	l
b3	ls.asm	/^  b3:	53                   	push   %ebx$/;"	l
b31	ls.asm	/^ b31:	e8 ed fe ff ff       	call   a23 <morecore>$/;"	l
b32	.asm	/^     b32:	a1 40 54 00 00       	mov    0x5440,%eax$/;"	l
b32	grep.asm	/^ b32:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
b35	grep.asm	/^ b35:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
b36	ls.asm	/^ b36:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
b37	.asm	/^     b37:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
b39	grep.asm	/^ b39:	75 07                	jne    b42 <malloc+0xcb>$/;"	l
b39	ls.asm	/^ b39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
b3a	.asm	/^     b3a:	c7 05 44 54 00 00 00 	movl   $0x0,0x5444$/;"	l
b3b	grep.asm	/^ b3b:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
b3d	ls.asm	/^ b3d:	75 07                	jne    b46 <malloc+0xcb>$/;"	l
b3f	ls.asm	/^ b3f:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
b4	.asm	/^      b4:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b4	echo.asm	/^  b4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
b4	grep.asm	/^  b4:	01 45 f4             	add    %eax,-0xc(%ebp)$/;"	l
b4	kill.asm	/^  b4:	84 c0                	test   %al,%al$/;"	l
b4	ln.asm	/^  b4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
b4	ls.asm	/^  b4:	81 ec 5c 02 00 00    	sub    $0x25c,%esp$/;"	l
b4	play.asm	/^  b4:	8b 84 24 28 00 01 00 	mov    0x10028(%esp),%eax$/;"	l
b40	grep.asm	/^ b40:	eb 13                	jmp    b55 <malloc+0xde>$/;"	l
b41	.asm	/^     b41:	00 00 00 $/;"	l
b42	grep.asm	/^ b42:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b44	.asm	/^     b44:	eb 7a                	jmp    bc0 <drawFinderContent+0x138>$/;"	l
b44	ls.asm	/^ b44:	eb 13                	jmp    b59 <malloc+0xde>$/;"	l
b45	grep.asm	/^ b45:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
b46	.asm	/^     b46:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b46	ls.asm	/^ b46:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b48	grep.asm	/^ b48:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b49	.asm	/^     b49:	8b 40 28             	mov    0x28(%eax),%eax$/;"	l
b49	ls.asm	/^ b49:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
b4b	grep.asm	/^ b4b:	8b 00                	mov    (%eax),%eax$/;"	l
b4c	.asm	/^     b4c:	8b 55 f4             	mov    -0xc(%ebp),%edx$/;"	l
b4c	ls.asm	/^ b4c:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b4d	grep.asm	/^ b4d:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
b4f	.asm	/^     b4f:	8b 52 14             	mov    0x14(%edx),%edx$/;"	l
b4f	ls.asm	/^ b4f:	8b 00                	mov    (%eax),%eax$/;"	l
b5	mkdir.asm	/^  b5:	90                   	nop$/;"	l
b50	grep.asm	/^ b50:	e9 70 ff ff ff       	jmp    ac5 <malloc+0x4e>$/;"	l
b51	ls.asm	/^ b51:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
b52	.asm	/^     b52:	89 44 24 34          	mov    %eax,0x34(%esp)$/;"	l
b54	ls.asm	/^ b54:	e9 70 ff ff ff       	jmp    ac9 <malloc+0x4e>$/;"	l
b55	grep.asm	/^ b55:	c9                   	leave  $/;"	l
b56	.asm	/^     b56:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b56	grep.asm	/^ b56:	c3                   	ret    $/;"	l
b59	.asm	/^     b59:	8b 48 18             	mov    0x18(%eax),%ecx$/;"	l
b59	ls.asm	/^ b59:	c9                   	leave  $/;"	l
b5a	ls.asm	/^ b5a:	c3                   	ret    $/;"	l
b5c	.asm	/^     b5c:	89 4c 24 24          	mov    %ecx,0x24(%esp)$/;"	l
b6	kill.asm	/^  b6:	75 de                	jne    96 <strcpy+0xd>$/;"	l
b6	mkdir.asm	/^  b6:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
b60	.asm	/^     b60:	8b 48 1c             	mov    0x1c(%eax),%ecx$/;"	l
b63	.asm	/^     b63:	89 4c 24 28          	mov    %ecx,0x28(%esp)$/;"	l
b67	.asm	/^     b67:	8b 48 20             	mov    0x20(%eax),%ecx$/;"	l
b6a	.asm	/^     b6a:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)$/;"	l
b6e	.asm	/^     b6e:	8b 40 24             	mov    0x24(%eax),%eax$/;"	l
b7	.asm	/^      b7:	89 50 2c             	mov    %edx,0x2c(%eax)$/;"	l
b7	cat.asm	/^  b7:	79 29                	jns    e2 <main+0x7a>$/;"	l
b7	decode.asm	/^  b7:	eb 04                	jmp    bd <strlen+0x13>$/;"	l
b7	forktest.asm	/^  b7:	e8 44 ff ff ff       	call   0 <printf>$/;"	l
b7	grep.asm	/^  b7:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b7	init.asm	/^  b7:	00 $/;"	l
b7	ln.asm	/^  b7:	88 10                	mov    %dl,(%eax)$/;"	l
b7	pause.asm	/^  b7:	eb 04                	jmp    bd <strlen+0x13>$/;"	l
b71	.asm	/^     b71:	89 44 24 30          	mov    %eax,0x30(%esp)$/;"	l
b75	.asm	/^     b75:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b78	.asm	/^     b78:	8b 08                	mov    (%eax),%ecx$/;"	l
b7a	.asm	/^     b7a:	89 4c 24 10          	mov    %ecx,0x10(%esp)$/;"	l
b7e	.asm	/^     b7e:	8b 48 04             	mov    0x4(%eax),%ecx$/;"	l
b8	echo.asm	/^  b8:	84 c0                	test   %al,%al$/;"	l
b8	init.asm	/^  b8:	c7 04 24 93 09 00 00 	movl   $0x993,(%esp)$/;"	l
b8	kill.asm	/^  b8:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
b81	.asm	/^     b81:	89 4c 24 14          	mov    %ecx,0x14(%esp)$/;"	l
b85	.asm	/^     b85:	8b 48 08             	mov    0x8(%eax),%ecx$/;"	l
b88	.asm	/^     b88:	89 4c 24 18          	mov    %ecx,0x18(%esp)$/;"	l
b8c	.asm	/^     b8c:	8b 48 0c             	mov    0xc(%eax),%ecx$/;"	l
b8f	.asm	/^     b8f:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)$/;"	l
b9	cat.asm	/^  b9:	8b 44 24 1c          	mov    0x1c(%esp),%eax$/;"	l
b9	decode.asm	/^  b9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)$/;"	l
b9	ln.asm	/^  b9:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
b9	mkdir.asm	/^  b9:	0f b6 10             	movzbl (%eax),%edx$/;"	l
b9	pause.asm	/^  b9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)$/;"	l
b93	.asm	/^     b93:	8b 40 10             	mov    0x10(%eax),%eax$/;"	l
b96	.asm	/^     b96:	89 44 24 20          	mov    %eax,0x20(%esp)$/;"	l
b9a	.asm	/^     b9a:	89 54 24 0c          	mov    %edx,0xc(%esp)$/;"	l
b9e	.asm	/^     b9e:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ba	.asm	/^      ba:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ba	echo.asm	/^  ba:	75 de                	jne    9a <strcpy+0xd>$/;"	l
ba	grep.asm	/^  ba:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
ba	ls.asm	/^  ba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
ba1	.asm	/^     ba1:	89 04 24             	mov    %eax,(%esp)$/;"	l
ba4	.asm	/^     ba4:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ba7	.asm	/^     ba7:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
bab	.asm	/^     bab:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
backcmd	sh.c	/^backcmd(struct cmd *subcmd)$/;"	f
backcmd	sh.c	/^struct backcmd {$/;"	s	file:
bae	.asm	/^     bae:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
balloc	fs.c	/^balloc(uint dev)$/;"	f	file:
balloc	mkfs.c	/^balloc(int used)$/;"	f
base	console.c	/^	uint base;$/;"	m	struct:__anon10	file:
base	umalloc.c	/^static Header base;$/;"	v	file:
base_15_0	mmu.h	/^  uint base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segdesc
base_23_16	mmu.h	/^  uint base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segdesc
base_31_24	mmu.h	/^  uint base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segdesc
bb	kill.asm	/^  bb:	c9                   	leave  $/;"	l
bb	play.asm	/^  bb:	3d 66 6d 74 20       	cmp    $0x20746d66,%eax$/;"	l
bb2	.asm	/^     bb2:	e8 e0 f8 ff ff       	call   497 <drawItem>$/;"	l
bb7	.asm	/^     bb7:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
bba	.asm	/^     bba:	8b 40 2c             	mov    0x2c(%eax),%eax$/;"	l
bbd	.asm	/^     bbd:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
bc	echo.asm	/^  bc:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
bc	forktest.asm	/^  bc:	e8 b7 02 00 00       	call   378 <exit>$/;"	l
bc	kill.asm	/^  bc:	c3                   	ret    $/;"	l
bc	ln.asm	/^  bc:	0f b6 00             	movzbl (%eax),%eax$/;"	l
bc	mkdir.asm	/^  bc:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
bc0	.asm	/^     bc0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
bc4	.asm	/^     bc4:	75 80                	jne    b46 <drawFinderContent+0xbe>$/;"	l
bc6	.asm	/^     bc6:	a1 64 51 00 00       	mov    0x5164,%eax$/;"	l
bcache	bio.c	/^} bcache;$/;"	v	typeref:struct:__anon2
bcb	.asm	/^     bcb:	83 f8 02             	cmp    $0x2,%eax$/;"	l
bce	.asm	/^     bce:	0f 85 39 01 00 00    	jne    d0d <drawFinderContent+0x285>$/;"	l
bcpu	mp.c	/^static struct cpu *bcpu;$/;"	v	typeref:struct:cpu	file:
bd	.asm	/^      bd:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)$/;"	l
bd	cat.asm	/^  bd:	c1 e0 02             	shl    $0x2,%eax$/;"	l
bd	decode.asm	/^  bd:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
bd	kill.asm	/^  bd:	55                   	push   %ebp$/;"	l
bd	pause.asm	/^  bd:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
bd4	.asm	/^     bd4:	c7 44 24 1c 14 a5 00 	movl   $0xa514,0x1c(%esp)$/;"	l
bdb	.asm	/^     bdb:	00 $/;"	l
bdc	.asm	/^     bdc:	c7 44 24 18 1c 00 00 	movl   $0x1c,0x18(%esp)$/;"	l
be	grep.asm	/^  be:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
be	kill.asm	/^  be:	89 e5                	mov    %esp,%ebp$/;"	l
be3	.asm	/^     be3:	00 $/;"	l
be4	.asm	/^     be4:	c7 44 24 14 26 00 00 	movl   $0x26,0x14(%esp)$/;"	l
beb	.asm	/^     beb:	00 $/;"	l
bec	.asm	/^     bec:	c7 44 24 10 47 00 00 	movl   $0x47,0x10(%esp)$/;"	l
begin_op	log.c	/^begin_op(void)$/;"	f
bf	echo.asm	/^  bf:	c9                   	leave  $/;"	l
bf	init.asm	/^  bf:	e8 60 03 00 00       	call   424 <exec>$/;"	l
bf	ln.asm	/^  bf:	84 c0                	test   %al,%al$/;"	l
bf	mkdir.asm	/^  bf:	88 10                	mov    %dl,(%eax)$/;"	l
bf3	.asm	/^     bf3:	00 $/;"	l
bf4	.asm	/^     bf4:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)$/;"	l
bfOffBits	bitmap.h	/^	DWORD bfOffBits; \/\/实际位图数据的偏移字节数，即前三个部分长度之和$/;"	m	struct:tagBITMAPFILEHEADER
bfReserved1	bitmap.h	/^	WORD bfReserved1; \/\/保留字，不考虑$/;"	m	struct:tagBITMAPFILEHEADER
bfReserved2	bitmap.h	/^	WORD bfReserved2; \/\/保留字，同上$/;"	m	struct:tagBITMAPFILEHEADER
bfSize	bitmap.h	/^	DWORD bfSize; \/\/文件大小$/;"	m	struct:tagBITMAPFILEHEADER
bfType	bitmap.h	/^	WORD bfType;\/\/固定为0x4d42$/;"	m	struct:tagBITMAPFILEHEADER
bfb	.asm	/^     bfb:	00 $/;"	l
bfc	.asm	/^     bfc:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
bff	.asm	/^     bff:	89 04 24             	mov    %eax,(%esp)$/;"	l
bfree	fs.c	/^bfree(int dev, uint b)$/;"	f	file:
bget	bio.c	/^bget(uint dev, uint sector)$/;"	f	file:
biBitCount	bitmap.h	/^	WORD biBitCount; \/\/采用颜色位数，可以是1，2，4，8，16，24，新的可以是32$/;"	m	struct:tagBITMAPINFOHEADER
biClrImportant	bitmap.h	/^	DWORD biClrImportant; \/\/重要颜色数，如果为0，则表示所有颜色都是重要的$/;"	m	struct:tagBITMAPINFOHEADER
biClrUsed	bitmap.h	/^	DWORD biClrUsed; \/\/使用的颜色数，如果为0，则表示默认值(2^颜色位数)$/;"	m	struct:tagBITMAPINFOHEADER
biCompression	bitmap.h	/^	DWORD biCompression; \/\/压缩方式，可以是0，1，2，其中0表示不压缩$/;"	m	struct:tagBITMAPINFOHEADER
biHeight	bitmap.h	/^	LONG biHeight; \/\/位图高$/;"	m	struct:tagBITMAPINFOHEADER
biPlanes	bitmap.h	/^	WORD biPlanes; \/\/平面数，为1$/;"	m	struct:tagBITMAPINFOHEADER
biSize	bitmap.h	/^	DWORD biSize; \/\/指定此结构体的长度，为40$/;"	m	struct:tagBITMAPINFOHEADER
biSizeImage	bitmap.h	/^	DWORD biSizeImage; \/\/实际位图数据占用的字节数$/;"	m	struct:tagBITMAPINFOHEADER
biWidth	bitmap.h	/^	LONG biWidth; \/\/位图宽$/;"	m	struct:tagBITMAPINFOHEADER
biXPelsPerMeter	bitmap.h	/^	LONG biXPelsPerMeter; \/\/X方向分辨率$/;"	m	struct:tagBITMAPINFOHEADER
biYPelsPerMeter	bitmap.h	/^	LONG biYPelsPerMeter; \/\/Y方向分辨率$/;"	m	struct:tagBITMAPINFOHEADER
big_values	common.h	/^			unsigned big_values;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
bigargtest	usertests.c	/^bigargtest(void)$/;"	f
bigdir	usertests.c	/^bigdir(void)$/;"	f
bigfile	usertests.c	/^bigfile(void)$/;"	f
bigwrite	usertests.c	/^bigwrite(void)$/;"	f
binit	bio.c	/^binit(void)$/;"	f
bit_stream_struc	common.h	/^typedef struct  bit_stream_struc {$/;"	s
bitblocks	mkfs.c	/^uint bitblocks;$/;"	v
bitrate	common.c	/^int bitrate[3][15] = {$/;"	v
bitrate_index	common.h	/^    int bitrate_index;$/;"	m	struct:__anon13
bits_per_sample	sound.h	/^  ushort bits_per_sample;$/;"	m	struct:fmt
block_type	common.h	/^			unsigned block_type;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
bmap	fs.c	/^bmap(struct inode *ip, uint bn)$/;"	f	file:
bootmain	bootmain.c	/^bootmain(void)$/;"	f
bp	.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	cat.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	decode.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	echo.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	grep.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	init.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	kill.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	ln.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	ls.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	mkdir.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	pause.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	play.asm	/^  bp = (Header*)ap - 1;$/;"	d
bread	bio.c	/^bread(uint dev, uint sector)$/;"	f
brelse	bio.c	/^brelse(struct buf *b)$/;"	f
bsstest	usertests.c	/^bsstest(void)$/;"	f
buf	bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon2	typeref:struct:__anon2::buf	file:
buf	buf.h	/^struct buf {$/;"	s
buf	cat.c	/^char buf[512];$/;"	v
buf	common.h	/^    unsigned char *buf;         \/*  *\/$/;"	m	struct:bit_stream_struc
buf	console.c	/^	char buf[INPUT_BUF];$/;"	m	struct:__anon9	file:
buf	drawingAPI.c	/^char buf[512];$/;"	v
buf	drawingAPI.h	/^	unsigned char * buf;$/;"	m	struct:File_Node
buf	grep.c	/^char buf[1024];$/;"	v
buf	sound.c	/^  uint buf;$/;"	m	struct:descriptor	file:
buf	sound.h	/^	unsigned int buf[BUFSIZE];$/;"	m	struct:coreBuf
buf	splice.c	/^char buf[512];$/;"	v
buf	sysaudio.c	/^char buf[8192];$/;"	v
buf	usertests.c	/^char buf[8192];$/;"	v
buf	wc.c	/^char buf[512];$/;"	v
buf_bit_idx	common.h	/^    int         buf_bit_idx;    \/* ָ򻺳ֽױ *\/$/;"	m	struct:bit_stream_struc
buf_bit_idx	sound.h	/^	unsigned int buf_bit_idx;$/;"	m	struct:coreBuf
buf_byte_idx	common.h	/^    int         buf_byte_idx;   \/* ָ򻺳ֽ *\/$/;"	m	struct:bit_stream_struc
buf_byte_idx	sound.h	/^	unsigned long offset, totbit, buf_byte_idx;$/;"	m	struct:coreBuf
buf_size	common.h	/^    int         buf_size;       \/* С( bytes) *\/$/;"	m	struct:bit_stream_struc
bufarray	console.c	/^	char bufarray[100][INPUT_BUF];$/;"	m	struct:__anon10	file:
bufcount	sysaudio.c	/^int bufcount;$/;"	v
buffer_CRC	decodemp3.c	/^void  buffer_CRC(Bit_stream_struc *bs, unsigned int *old_crc)$/;"	f
bwrite	bio.c	/^bwrite(struct buf *b)$/;"	f
bytes_per_sample	sound.h	/^  ushort bytes_per_sample;$/;"	m	struct:fmt
bytes_per_sec	sound.h	/^  uint bytes_per_sec;$/;"	m	struct:fmt
bzero	fs.c	/^bzero(int dev, int bno)$/;"	f	file:
c	.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	cat.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	decode.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	echo.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	forktest.asm	/^   c:	e8 9d 01 00 00       	call   1ae <strlen>$/;"	l
c	grep.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	init.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	kill.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	ln.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	ls.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	mkdir.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	pause.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	play.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	play.asm	/^   c:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
c0	cat.asm	/^  c0:	03 45 0c             	add    0xc(%ebp),%eax$/;"	l
c0	decode.asm	/^  c0:	03 45 08             	add    0x8(%ebp),%eax$/;"	l
c0	echo.asm	/^  c0:	c3                   	ret    $/;"	l
c0	kill.asm	/^  c0:	eb 08                	jmp    ca <strcmp+0xd>$/;"	l
c0	pause.asm	/^  c0:	03 45 08             	add    0x8(%ebp),%eax$/;"	l
c0	play.asm	/^  c0:	75 2a                	jne    ec <main+0xec>$/;"	l
c02	.asm	/^     c02:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
c05	.asm	/^     c05:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
c09	.asm	/^     c09:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
c0c	.asm	/^     c0c:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
c1	echo.asm	/^  c1:	55                   	push   %ebp$/;"	l
c1	forktest.asm	/^  c1:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)$/;"	l
c1	grep.asm	/^  c1:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
c1	ln.asm	/^  c1:	0f 95 c0             	setne  %al$/;"	l
c1	ls.asm	/^  c1:	00 $/;"	l
c1	mkdir.asm	/^  c1:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c10	.asm	/^     c10:	e8 b4 12 00 00       	call   1ec9 <fill_rect>$/;"	l
c15	.asm	/^     c15:	c7 44 24 1c 14 a5 00 	movl   $0xa514,0x1c(%esp)$/;"	l
c1c	.asm	/^     c1c:	00 $/;"	l
c1d	.asm	/^     c1d:	c7 44 24 18 1c 00 00 	movl   $0x1c,0x18(%esp)$/;"	l
c2	echo.asm	/^  c2:	89 e5                	mov    %esp,%ebp$/;"	l
c2	kill.asm	/^  c2:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
c2	ls.asm	/^  c2:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c2	play.asm	/^  c2:	0f b7 84 24 32 00 01 	movzwl 0x10032(%esp),%eax$/;"	l
c24	.asm	/^     c24:	00 $/;"	l
c25	.asm	/^     c25:	c7 44 24 14 9f 00 00 	movl   $0x9f,0x14(%esp)$/;"	l
c2c	.asm	/^     c2c:	00 $/;"	l
c2d	.asm	/^     c2d:	c7 44 24 10 47 00 00 	movl   $0x47,0x10(%esp)$/;"	l
c3	cat.asm	/^  c3:	8b 00                	mov    (%eax),%eax$/;"	l
c3	decode.asm	/^  c3:	0f b6 00             	movzbl (%eax),%eax$/;"	l
c3	pause.asm	/^  c3:	0f b6 00             	movzbl (%eax),%eax$/;"	l
c34	.asm	/^     c34:	00 $/;"	l
c35	.asm	/^     c35:	c7 44 24 0c 28 00 00 	movl   $0x28,0xc(%esp)$/;"	l
c3c	.asm	/^     c3c:	00 $/;"	l
c3d	.asm	/^     c3d:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c4	.asm	/^      c4:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
c4	echo.asm	/^  c4:	eb 08                	jmp    ce <strcmp+0xd>$/;"	l
c4	init.asm	/^  c4:	c7 44 24 04 e8 09 00 	movl   $0x9e8,0x4(%esp)$/;"	l
c4	ln.asm	/^  c4:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
c4	mkdir.asm	/^  c4:	0f b6 00             	movzbl (%eax),%eax$/;"	l
c40	.asm	/^     c40:	89 04 24             	mov    %eax,(%esp)$/;"	l
c43	.asm	/^     c43:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
c46	.asm	/^     c46:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
c4a	.asm	/^     c4a:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
c4d	.asm	/^     c4d:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
c5	cat.asm	/^  c5:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
c5	forktest.asm	/^  c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
c5	grep.asm	/^  c5:	c7 04 24 a0 0e 00 00 	movl   $0xea0,(%esp)$/;"	l
c5	ls.asm	/^  c5:	89 04 24             	mov    %eax,(%esp)$/;"	l
c51	.asm	/^     c51:	e8 73 12 00 00       	call   1ec9 <fill_rect>$/;"	l
c56	.asm	/^     c56:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
c59	.asm	/^     c59:	2d c9 00 00 00       	sub    $0xc9,%eax$/;"	l
c5e	.asm	/^     c5e:	c7 44 24 1c 14 a5 00 	movl   $0xa514,0x1c(%esp)$/;"	l
c6	decode.asm	/^  c6:	84 c0                	test   %al,%al$/;"	l
c6	echo.asm	/^  c6:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
c6	kill.asm	/^  c6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
c6	pause.asm	/^  c6:	84 c0                	test   %al,%al$/;"	l
c65	.asm	/^     c65:	00 $/;"	l
c66	.asm	/^     c66:	c7 44 24 18 1c 00 00 	movl   $0x1c,0x18(%esp)$/;"	l
c6d	.asm	/^     c6d:	00 $/;"	l
c6e	.asm	/^     c6e:	89 44 24 14          	mov    %eax,0x14(%esp)$/;"	l
c7	.asm	/^      c7:	a3 40 54 00 00       	mov    %eax,0x5440$/;"	l
c7	mkdir.asm	/^  c7:	84 c0                	test   %al,%al$/;"	l
c72	.asm	/^     c72:	c7 44 24 10 47 00 00 	movl   $0x47,0x10(%esp)$/;"	l
c79	.asm	/^     c79:	00 $/;"	l
c7a	.asm	/^     c7a:	c7 44 24 0c c8 00 00 	movl   $0xc8,0xc(%esp)$/;"	l
c8	decode.asm	/^  c8:	75 ef                	jne    b9 <strlen+0xf>$/;"	l
c8	ln.asm	/^  c8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
c8	ls.asm	/^  c8:	e8 2b 05 00 00       	call   5f8 <open>$/;"	l
c8	pause.asm	/^  c8:	75 ef                	jne    b9 <strlen+0xf>$/;"	l
c81	.asm	/^     c81:	00 $/;"	l
c82	.asm	/^     c82:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c85	.asm	/^     c85:	89 04 24             	mov    %eax,(%esp)$/;"	l
c88	.asm	/^     c88:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
c8b	.asm	/^     c8b:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
c8f	.asm	/^     c8f:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
c9	cat.asm	/^  c9:	c7 44 24 04 28 09 00 	movl   $0x928,0x4(%esp)$/;"	l
c9	forktest.asm	/^  c9:	7f d4                	jg     9f <forktest+0x76>$/;"	l
c9	mkdir.asm	/^  c9:	0f 95 c0             	setne  %al$/;"	l
c9	play.asm	/^  c9:	00 $/;"	l
c92	.asm	/^     c92:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
c96	.asm	/^     c96:	e8 2e 12 00 00       	call   1ec9 <fill_rect>$/;"	l
c9b	.asm	/^     c9b:	c7 44 24 18 50 00 00 	movl   $0x50,0x18(%esp)$/;"	l
ca	decode.asm	/^  ca:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
ca	echo.asm	/^  ca:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
ca	kill.asm	/^  ca:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ca	pause.asm	/^  ca:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
ca	play.asm	/^  ca:	66 83 f8 02          	cmp    $0x2,%ax$/;"	l
ca2	.asm	/^     ca2:	00 $/;"	l
ca3	.asm	/^     ca3:	c7 44 24 14 2b 00 00 	movl   $0x2b,0x14(%esp)$/;"	l
caa	.asm	/^     caa:	00 $/;"	l
cab	.asm	/^     cab:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)$/;"	l
cal	cal.c	/^int cal(char* src)$/;"	f
cal3	cal.c	/^char* cal3(char* a1, char* a2, char* s)$/;"	f
caln	cal.c	/^char* caln(char** src)$/;"	f
cat	cat.c	/^cat(int fd)$/;"	f
cb	forktest.asm	/^  cb:	e8 b0 02 00 00       	call   380 <wait>$/;"	l
cb	init.asm	/^  cb:	00 $/;"	l
cb2	.asm	/^     cb2:	00 $/;"	l
cb3	.asm	/^     cb3:	c7 44 24 0c cb 41 00 	movl   $0x41cb,0xc(%esp)$/;"	l
cba	.asm	/^     cba:	00 $/;"	l
cbb	.asm	/^     cbb:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
cbe	.asm	/^     cbe:	89 04 24             	mov    %eax,(%esp)$/;"	l
cc	.asm	/^      cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx$/;"	l
cc	.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	cat.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	decode.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	echo.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	forktest.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	grep.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	grep.asm	/^  cc:	e8 9d 04 00 00       	call   56e <memmove>$/;"	l
cc	init.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	init.asm	/^  cc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
cc	kill.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ln.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ln.asm	/^  cc:	84 c0                	test   %al,%al$/;"	l
cc	ls.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	mkdir.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	mkdir.asm	/^  cc:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
cc	pause.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	play.asm	/^    cc = read(0, &c, 1);$/;"	d
cc1	.asm	/^     cc1:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
cc4	.asm	/^     cc4:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
cc8	.asm	/^     cc8:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
ccb	.asm	/^     ccb:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
ccf	.asm	/^     ccf:	e8 f5 17 00 00       	call   24c9 <puts_str>$/;"	l
cd	decode.asm	/^  cd:	c9                   	leave  $/;"	l
cd	kill.asm	/^  cd:	0f b6 00             	movzbl (%eax),%eax$/;"	l
cd	ls.asm	/^  cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)$/;"	l
cd	pause.asm	/^  cd:	c9                   	leave  $/;"	l
cd4	.asm	/^     cd4:	c7 44 24 18 50 00 00 	movl   $0x50,0x18(%esp)$/;"	l
cdb	.asm	/^     cdb:	00 $/;"	l
cdc	.asm	/^     cdc:	c7 44 24 14 cb 00 00 	movl   $0xcb,0x14(%esp)$/;"	l
ce	decode.asm	/^  ce:	c3                   	ret    $/;"	l
ce	echo.asm	/^  ce:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ce	ln.asm	/^  ce:	75 de                	jne    ae <strcpy+0xd>$/;"	l
ce	pause.asm	/^  ce:	c3                   	ret    $/;"	l
ce	play.asm	/^  ce:	75 1c                	jne    ec <main+0xec>$/;"	l
ce3	.asm	/^     ce3:	00 $/;"	l
ce4	.asm	/^     ce4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)$/;"	l
ceb	.asm	/^     ceb:	00 $/;"	l
cec	.asm	/^     cec:	c7 44 24 0c d0 41 00 	movl   $0x41d0,0xc(%esp)$/;"	l
cf	.asm	/^      cf:	c9                   	leave  $/;"	l
cf	decode.asm	/^  cf:	55                   	push   %ebp$/;"	l
cf	pause.asm	/^  cf:	55                   	push   %ebp$/;"	l
cf3	.asm	/^     cf3:	00 $/;"	l
cf4	.asm	/^     cf4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
cf7	.asm	/^     cf7:	89 04 24             	mov    %eax,(%esp)$/;"	l
cfa	.asm	/^     cfa:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
cfd	.asm	/^     cfd:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
cgaputc	console.c	/^cgaputc(int c)$/;"	f	file:
ch	common.h	/^	} ch[2];$/;"	m	struct:III_side_info_t	typeref:struct:III_side_info_t::__anon14
chan	proc.h	/^  void *chan;                  \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc
changed	editor.c	/^int changed = 0;$/;"	v
channel	sound.h	/^  ushort channel;$/;"	m	struct:fmt
char	.asm	/^char * int2str(int i)$/;"	l
char	.asm	/^char *sizeFormat(uint size){$/;"	l
char	.asm	/^char buf[512];$/;"	l
char	cat.asm	/^char buf[512];$/;"	l
char	grep.asm	/^char buf[1024];$/;"	l
char	init.asm	/^char *argv[] = { "sh", 0 };$/;"	l
char	init.asm	/^char *desktop_argv[] = { "desktop", 0 };$/;"	l
chars_to_int	cal.c	/^int chars_to_int(char* src)$/;"	f
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mp
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mpconf
chosen	finder.c	/^	int chosen;$/;"	m	struct:fileItem	file:
clearpteu	vm.c	/^clearpteu(pde_t *pgdir, char *uva)$/;"	f
cli	x86.h	/^cli(void)$/;"	f
close_bit_stream_r	common.c	/^void close_bit_stream_r(Bit_stream_struc *bs)$/;"	f
cm	.asm	/^	cm = initClickManager(context);$/;"	d
cm	finder.c	/^ClickableManager cm;$/;"	v
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:backcmd	typeref:struct:backcmd::cmd	file:
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:redircmd	typeref:struct:redircmd::cmd	file:
cmd	sh.c	/^struct cmd {$/;"	s	file:
cmd_len	sound.c	/^  uint cmd_len;$/;"	m	struct:descriptor	file:
cmos_read	lapic.c	/^static uint cmos_read(uint reg)$/;"	f	file:
cmostime	lapic.c	/^void cmostime(struct rtcdate *r)$/;"	f
color	.asm	/^			color = (unsigned short)_RGB16BIT565(rgb.rgbRed, rgb.rgbGreen, rgb.rgbBlue);$/;"	d
color	console.c	/^int color[16] = { 0x0000, 0x0100, 0x0200, 0x0300, 0x0400, 0x0500, 0x0600, 0x0700,$/;"	v
color16	window.h	/^typedef unsigned short color16;$/;"	t
com_del	editor.c	/^void com_del(char *text[], int n)$/;"	f
com_exit	editor.c	/^void com_exit(char *text[], char *path)$/;"	f
com_help	editor.c	/^void com_help(char *text[])$/;"	f
com_ins	editor.c	/^void com_ins(char *text[], int n, char *extra)$/;"	f
com_mod	editor.c	/^void com_mod(char *text[], int n, char *extra)$/;"	f
com_save	editor.c	/^void com_save(char *text[], char *path)$/;"	f
command	console.c	/^char *command[COMMANDNUM] = { "cat", "cd", "cp", "echo", "forktest", "grep", "help", "init", "kill", "ln", "ls",$/;"	v
command	sh.c	/^char *command[COMMANDNUM] = { "cat", "cd", "cp", "echo", "forktest", "grep", "init", "kill", "ln", "ls",$/;"	v
commandfilled	console.c	/^int commandfilled = 1;$/;"	v
commit	log.c	/^commit()$/;"	f	file:
committing	log.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:
concreate	usertests.c	/^concreate(void)$/;"	f
concrete_msg	message.h	/^	} concrete_msg;$/;"	m	struct:Msg	typeref:union:Msg::__anon7
cons	console.c	/^} cons;$/;"	v	typeref:struct:__anon11	file:
consoleinit	console.c	/^consoleinit(void)$/;"	f
consoleintr	console.c	/^consoleintr(int (*getc)(void), int type)$/;"	f
consoleread	console.c	/^consoleread(struct inode *ip, char *dst, int n)$/;"	f
consolewrite	console.c	/^consolewrite(struct inode *ip, char *buf, int n)$/;"	f
consputc	console.c	/^consputc(int c)$/;"	f
contentRes	finder.c	/^struct Icon contentRes[] = { { "file_icon_big.bmp", 0, 0 }, {$/;"	v	typeref:struct:Icon
context	finder.c	/^struct Context context;$/;"	v	typeref:struct:Context
context	proc.h	/^  struct context *context;     \/\/ swtch() here to run process$/;"	m	struct:proc	typeref:struct:proc::context
context	proc.h	/^struct context {$/;"	s
context	shell.c	/^struct Context context;$/;"	v	typeref:struct:Context
copyout	vm.c	/^copyout(pde_t *pgdir, uint va, void *p, uint len)$/;"	f
copyright	common.h	/^    int copyright;$/;"	m	struct:__anon13
copyuvm	vm.c	/^copyuvm(pde_t *pgdir, uint sz)$/;"	f
coreBuf	sound.h	/^struct coreBuf{$/;"	s
corebuf	sysaudio.c	/^static struct coreBuf corebuf;$/;"	v	typeref:struct:coreBuf	file:
cos	math.c	/^double cos(double x)  $/;"	f
count1table_select	common.h	/^			unsigned count1table_select;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
counter	.asm	/^			counter = 1;$/;"	d
counter	.asm	/^			counter = atoi(&name[baseLen]);$/;"	d
cprintf	console.c	/^cprintf(char *fmt, ...)$/;"	f
cpu	proc.h	/^  struct cpu *cpu;$/;"	m	struct:cpu	typeref:struct:cpu::cpu
cpu	proc.h	/^struct cpu {$/;"	s
cpu	spinlock.h	/^  struct cpu *cpu;   \/\/ The cpu holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::cpu
cpunum	lapic.c	/^cpunum(void)$/;"	f
cpus	mp.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu
cr3	mmu.h	/^  void *cr3;         \/\/ Page directory base$/;"	m	struct:taskstate
create	sysfile.c	/^create(char *path, short type, short major, short minor)$/;"	f	file:
createClickable	clickable.c	/^void createClickable(ClickableManager *c, Rect r, int MsgType, Handler h)$/;"	f
createMsg	message.c	/^void createMsg(int msg_type, int pos_x, int pos_y, char key)$/;"	f
createPartialUpdateMsg	message.c	/^void createPartialUpdateMsg(int pid, int x1, int y1, int x2, int y2)$/;"	f
createUpdateMsg	message.c	/^void createUpdateMsg(int pid)$/;"	f
create_syn_filter	decodemp3.c	/^void create_syn_filter(double filter[64][SBLIMIT])$/;"	f
createdelete	usertests.c	/^createdelete(void)$/;"	f
createtest	usertests.c	/^createtest(void)$/;"	f
crt	console.c	/^static ushort *crt = (ushort*)P2V(0xb8000);  \/\/ CGA memory$/;"	v	file:
cs	mmu.h	/^  uint cs : 16;         \/\/ code segment selector$/;"	m	struct:gatedesc
cs	mmu.h	/^  ushort cs;$/;"	m	struct:taskstate
cs	x86.h	/^  ushort cs;$/;"	m	struct:trapframe
ctlmap	kbd.h	/^static uchar ctlmap[256] =$/;"	v
cur	.asm	/^				cur = cur->next;$/;"	d
cur	.asm	/^				cur = prev = *head;$/;"	d
cur	.asm	/^		cur = cur->next;$/;"	d
cwd	proc.h	/^  struct inode *cwd;           \/\/ Current directory$/;"	m	struct:proc	typeref:struct:proc::inode
d	decode.asm	/^   d:	90                   	nop$/;"	l
d	grep.asm	/^   d:	e9 bf 00 00 00       	jmp    d1 <grep+0xd1>$/;"	l
d	kill.asm	/^   d:	7f 19                	jg     28 <main+0x28>$/;"	l
d	ln.asm	/^   d:	74 19                	je     28 <main+0x28>$/;"	l
d	ls.asm	/^   d:	e8 dc 03 00 00       	call   3ee <strlen>$/;"	l
d	mkdir.asm	/^   d:	7f 19                	jg     28 <main+0x28>$/;"	l
d0	.asm	/^      d0:	c3                   	ret    $/;"	l
d0	cat.asm	/^  d0:	00 $/;"	l
d0	decode.asm	/^  d0:	89 e5                	mov    %esp,%ebp$/;"	l
d0	forktest.asm	/^  d0:	83 f8 ff             	cmp    $0xffffffff,%eax$/;"	l
d0	kill.asm	/^  d0:	84 c0                	test   %al,%al$/;"	l
d0	ln.asm	/^  d0:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
d0	ls.asm	/^  d0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)$/;"	l
d0	mkdir.asm	/^  d0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
d0	pause.asm	/^  d0:	89 e5                	mov    %esp,%ebp$/;"	l
d0	play.asm	/^  d0:	0f b7 84 24 3c 00 01 	movzwl 0x1003c(%esp),%eax$/;"	l
d01	.asm	/^     d01:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
d04	.asm	/^     d04:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
d08	.asm	/^     d08:	e8 bc 17 00 00       	call   24c9 <puts_str>$/;"	l
d0d	.asm	/^     d0d:	c9                   	leave  $/;"	l
d0e	.asm	/^     d0e:	c3                   	ret    $/;"	l
d0f	.asm	/^     d0f:	55                   	push   %ebp$/;"	l
d1	.asm	/^      d1:	55                   	push   %ebp$/;"	l
d1	cat.asm	/^  d1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
d1	echo.asm	/^  d1:	0f b6 00             	movzbl (%eax),%eax$/;"	l
d1	grep.asm	/^  d1:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
d10	.asm	/^     d10:	89 e5                	mov    %esp,%ebp$/;"	l
d12	.asm	/^     d12:	53                   	push   %ebx$/;"	l
d13	.asm	/^     d13:	83 ec 24             	sub    $0x24,%esp$/;"	l
d16	.asm	/^     d16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)$/;"	l
d1d	.asm	/^     d1d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)$/;"	l
d2	.asm	/^      d2:	89 e5                	mov    %esp,%ebp$/;"	l
d2	decode.asm	/^  d2:	83 ec 0c             	sub    $0xc,%esp$/;"	l
d2	kill.asm	/^  d2:	74 10                	je     e4 <strcmp+0x27>$/;"	l
d2	pause.asm	/^  d2:	83 ec 0c             	sub    $0xc,%esp$/;"	l
d24	.asm	/^     d24:	e8 72 33 00 00       	call   409b <malloc>$/;"	l
d29	.asm	/^     d29:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
d2c	.asm	/^     d2c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)$/;"	l
d3	forktest.asm	/^  d3:	74 19                	je     ee <forktest+0xc5>$/;"	l
d3	init.asm	/^  d3:	e8 f3 04 00 00       	call   5cb <printf>$/;"	l
d3	ln.asm	/^  d3:	c9                   	leave  $/;"	l
d33	.asm	/^     d33:	e8 63 33 00 00       	call   409b <malloc>$/;"	l
d38	.asm	/^     d38:	89 45 e8             	mov    %eax,-0x18(%ebp)$/;"	l
d3b	.asm	/^     d3b:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
d3e	.asm	/^     d3e:	89 c3                	mov    %eax,%ebx$/;"	l
d4	.asm	/^      d4:	83 ec 28             	sub    $0x28,%esp$/;"	l
d4	echo.asm	/^  d4:	84 c0                	test   %al,%al$/;"	l
d4	grep.asm	/^  d4:	ba 00 04 00 00       	mov    $0x400,%edx$/;"	l
d4	kill.asm	/^  d4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d4	ln.asm	/^  d4:	c3                   	ret    $/;"	l
d4	ls.asm	/^  d4:	79 20                	jns    f6 <ls+0x48>$/;"	l
d4	mkdir.asm	/^  d4:	84 c0                	test   %al,%al$/;"	l
d40	.asm	/^     d40:	03 5d ec             	add    -0x14(%ebp),%ebx$/;"	l
d43	.asm	/^     d43:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
d46	.asm	/^     d46:	ba 67 66 66 66       	mov    $0x66666667,%edx$/;"	l
d4b	.asm	/^     d4b:	89 c8                	mov    %ecx,%eax$/;"	l
d4d	.asm	/^     d4d:	f7 ea                	imul   %edx$/;"	l
d4f	.asm	/^     d4f:	c1 fa 02             	sar    $0x2,%edx$/;"	l
d5	decode.asm	/^  d5:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
d5	forktest.asm	/^  d5:	c7 44 24 04 bf 04 00 	movl   $0x4bf,0x4(%esp)$/;"	l
d5	ln.asm	/^  d5:	55                   	push   %ebp$/;"	l
d5	pause.asm	/^  d5:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
d52	.asm	/^     d52:	89 c8                	mov    %ecx,%eax$/;"	l
d54	.asm	/^     d54:	c1 f8 1f             	sar    $0x1f,%eax$/;"	l
d57	.asm	/^     d57:	29 c2                	sub    %eax,%edx$/;"	l
d59	.asm	/^     d59:	89 d0                	mov    %edx,%eax$/;"	l
d5b	.asm	/^     d5b:	c1 e0 02             	shl    $0x2,%eax$/;"	l
d5e	.asm	/^     d5e:	01 d0                	add    %edx,%eax$/;"	l
d6	echo.asm	/^  d6:	74 10                	je     e8 <strcmp+0x27>$/;"	l
d6	ln.asm	/^  d6:	89 e5                	mov    %esp,%ebp$/;"	l
d6	ls.asm	/^  d6:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d6	mkdir.asm	/^  d6:	75 de                	jne    b6 <strcpy+0xd>$/;"	l
d60	.asm	/^     d60:	01 c0                	add    %eax,%eax$/;"	l
d62	.asm	/^     d62:	89 ca                	mov    %ecx,%edx$/;"	l
d64	.asm	/^     d64:	29 c2                	sub    %eax,%edx$/;"	l
d66	.asm	/^     d66:	89 d0                	mov    %edx,%eax$/;"	l
d68	.asm	/^     d68:	83 c0 30             	add    $0x30,%eax$/;"	l
d6b	.asm	/^     d6b:	88 03                	mov    %al,(%ebx)$/;"	l
d6d	.asm	/^     d6d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)$/;"	l
d7	.asm	/^      d7:	a1 40 54 00 00       	mov    0x5440,%eax$/;"	l
d7	kill.asm	/^  d7:	0f b6 10             	movzbl (%eax),%edx$/;"	l
d7	play.asm	/^  d7:	00 $/;"	l
d71	.asm	/^     d71:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
d74	.asm	/^     d74:	ba 67 66 66 66       	mov    $0x66666667,%edx$/;"	l
d79	.asm	/^     d79:	89 c8                	mov    %ecx,%eax$/;"	l
d7b	.asm	/^     d7b:	f7 ea                	imul   %edx$/;"	l
d7d	.asm	/^     d7d:	c1 fa 02             	sar    $0x2,%edx$/;"	l
d8	cat.asm	/^  d8:	e8 76 04 00 00       	call   553 <printf>$/;"	l
d8	decode.asm	/^  d8:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
d8	echo.asm	/^  d8:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d8	init.asm	/^  d8:	e8 0f 03 00 00       	call   3ec <exit>$/;"	l
d8	ln.asm	/^  d8:	eb 08                	jmp    e2 <strcmp+0xd>$/;"	l
d8	mkdir.asm	/^  d8:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
d8	pause.asm	/^  d8:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
d8	play.asm	/^  d8:	66 83 f8 04          	cmp    $0x4,%ax$/;"	l
d80	.asm	/^     d80:	89 c8                	mov    %ecx,%eax$/;"	l
d82	.asm	/^     d82:	c1 f8 1f             	sar    $0x1f,%eax$/;"	l
d85	.asm	/^     d85:	89 d1                	mov    %edx,%ecx$/;"	l
d87	.asm	/^     d87:	29 c1                	sub    %eax,%ecx$/;"	l
d89	.asm	/^     d89:	89 c8                	mov    %ecx,%eax$/;"	l
d8b	.asm	/^     d8b:	89 45 08             	mov    %eax,0x8(%ebp)$/;"	l
d8e	.asm	/^     d8e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)$/;"	l
d9	grep.asm	/^  d9:	89 d1                	mov    %edx,%ecx$/;"	l
d9	ls.asm	/^  d9:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
d92	.asm	/^     d92:	75 a7                	jne    d3b <int2str+0x2c>$/;"	l
d94	.asm	/^     d94:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
d97	.asm	/^     d97:	03 45 ec             	add    -0x14(%ebp),%eax$/;"	l
d9a	.asm	/^     d9a:	c6 00 00             	movb   $0x0,(%eax)$/;"	l
d9d	.asm	/^     d9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)$/;"	l
da	kill.asm	/^  da:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
da	ln.asm	/^  da:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
da4	.asm	/^     da4:	eb 1b                	jmp    dc1 <int2str+0xb2>$/;"	l
da6	.asm	/^     da6:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
da9	.asm	/^     da9:	03 45 e8             	add    -0x18(%ebp),%eax$/;"	l
dac	.asm	/^     dac:	8b 55 f0             	mov    -0x10(%ebp),%edx$/;"	l
daf	.asm	/^     daf:	83 ea 01             	sub    $0x1,%edx$/;"	l
data	bitmap.h	/^	RGBQUAD *data;$/;"	m	struct:PicNode
data	buf.h	/^  uchar data[512];$/;"	m	struct:buf
data	ioapic.c	/^  uint data;$/;"	m	struct:ioapic	file:
data	pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:
data	sound.h	/^  uchar data[DMA_BUF_NUM*DMA_BUF_SIZE];$/;"	m	struct:soundNode
dataOfBmp	.asm	/^	dataOfBmp = (RGBQUAD *)malloc(width*height*sizeof(RGBQUAD));\/\/用于保存各像素对应的RGB数据$/;"	d
data_id	sound.h	/^  uint data_id;$/;"	m	struct:wav
datacount	sysaudio.c	/^int datacount;$/;"	v
day	date.h	/^	uint day;$/;"	m	struct:rtcdate
db	echo.asm	/^  db:	0f b6 10             	movzbl (%eax),%edx$/;"	l
db	grep.asm	/^  db:	29 c1                	sub    %eax,%ecx$/;"	l
db	mkdir.asm	/^  db:	c9                   	leave  $/;"	l
db	mmu.h	/^  uint db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segdesc
db2	.asm	/^     db2:	2b 55 f4             	sub    -0xc(%ebp),%edx$/;"	l
db5	.asm	/^     db5:	03 55 ec             	add    -0x14(%ebp),%edx$/;"	l
db8	.asm	/^     db8:	0f b6 12             	movzbl (%edx),%edx$/;"	l
dbb	.asm	/^     dbb:	88 10                	mov    %dl,(%eax)$/;"	l
dbd	.asm	/^     dbd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)$/;"	l
dc	.asm	/^      dc:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
dc	decode.asm	/^  dc:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
dc	forktest.asm	/^  dc:	00 $/;"	l
dc	mkdir.asm	/^  dc:	c3                   	ret    $/;"	l
dc	pause.asm	/^  dc:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
dc	play.asm	/^  dc:	75 0e                	jne    ec <main+0xec>$/;"	l
dc1	.asm	/^     dc1:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
dc4	.asm	/^     dc4:	3b 45 f0             	cmp    -0x10(%ebp),%eax$/;"	l
dc7	.asm	/^     dc7:	7c dd                	jl     da6 <int2str+0x97>$/;"	l
dc9	.asm	/^     dc9:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
dcc	.asm	/^     dcc:	03 45 e8             	add    -0x18(%ebp),%eax$/;"	l
dcf	.asm	/^     dcf:	c6 00 00             	movb   $0x0,(%eax)$/;"	l
dd	cat.asm	/^  dd:	e8 92 02 00 00       	call   374 <exit>$/;"	l
dd	forktest.asm	/^  dd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
dd	grep.asm	/^  dd:	89 c8                	mov    %ecx,%eax$/;"	l
dd	init.asm	/^  dd:	c7 44 24 04 0b 0a 00 	movl   $0xa0b,0x4(%esp)$/;"	l
dd	kill.asm	/^  dd:	0f b6 00             	movzbl (%eax),%eax$/;"	l
dd	ls.asm	/^  dd:	c7 44 24 04 5b 0b 00 	movl   $0xb5b,0x4(%esp)$/;"	l
dd	mkdir.asm	/^  dd:	55                   	push   %ebp$/;"	l
dd2	.asm	/^     dd2:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
dd5	.asm	/^     dd5:	89 04 24             	mov    %eax,(%esp)$/;"	l
dd8	.asm	/^     dd8:	e8 8f 31 00 00       	call   3f6c <free>$/;"	l
ddd	.asm	/^     ddd:	8b 45 e8             	mov    -0x18(%ebp),%eax$/;"	l
de	echo.asm	/^  de:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
de	ln.asm	/^  de:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
de	mkdir.asm	/^  de:	89 e5                	mov    %esp,%ebp$/;"	l
de	play.asm	/^  de:	0f b7 84 24 3e 00 01 	movzwl 0x1003e(%esp),%eax$/;"	l
de0	.asm	/^     de0:	83 c4 24             	add    $0x24,%esp$/;"	l
de3	.asm	/^     de3:	5b                   	pop    %ebx$/;"	l
de4	.asm	/^     de4:	5d                   	pop    %ebp$/;"	l
de5	.asm	/^     de5:	c3                   	ret    $/;"	l
de6	.asm	/^     de6:	55                   	push   %ebp$/;"	l
de7	.asm	/^     de7:	89 e5                	mov    %esp,%ebp$/;"	l
de9	.asm	/^     de9:	83 ec 28             	sub    $0x28,%esp$/;"	l
deallocuvm	vm.c	/^deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f
dec	.asm	/^     dec:	a1 40 54 00 00       	mov    0x5440,%eax$/;"	l
decode	sysaudio.c	/^struct decode {$/;"	s	file:
decode_info	decodemp3.c	/^void decode_info(Bit_stream_struc *bs, struct frame_params *fr_ps)$/;"	f
decodelock	sysaudio.c	/^struct decode decodelock, mp3lock;$/;"	v	typeref:struct:decode
default	.asm	/^		default:$/;"	l
default	.asm	/^	    default:$/;"	l
default	.asm	/^	default:$/;"	l
deleteClickable	clickable.c	/^void deleteClickable(Clickable **head, Rect region)$/;"	f
deleteFile	finder.c	/^void deleteFile(char *name)$/;"	f
desalloc_buffer	common.c	/^void desalloc_buffer(Bit_stream_struc *bs)$/;"	f
descriTable	sound.c	/^static struct descriptor descriTable[DMA_BUF_NUM];$/;"	v	typeref:struct:descriptor	file:
descriptor	sound.c	/^struct descriptor{$/;"	s	file:
desktop_argv	init.c	/^char *desktop_argv[] = { "desktop", 0 };$/;"	v
desktop_pid	init.asm	/^    desktop_pid = fork();$/;"	d
dev	buf.h	/^  uint dev;$/;"	m	struct:buf
dev	file.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode
dev	log.c	/^  int dev;$/;"	m	struct:log	file:
dev	stat.h	/^  int dev;     \/\/ File system's disk device$/;"	m	struct:stat
devsw	file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw
devsw	file.h	/^struct devsw {$/;"	s
df	.asm	/^      df:	eb 28                	jmp    109 <freeFileItemList+0x38>$/;"	l
df	decode.asm	/^  df:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
df	grep.asm	/^  df:	8b 55 f4             	mov    -0xc(%ebp),%edx$/;"	l
df	pause.asm	/^  df:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
df1	.asm	/^     df1:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
df4	.asm	/^     df4:	eb 27                	jmp    e1d <printItemList+0x37>$/;"	l
df6	.asm	/^     df6:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
df9	.asm	/^     df9:	8b 40 14             	mov    0x14(%eax),%eax$/;"	l
dfc	.asm	/^     dfc:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
dinode	fs.h	/^struct dinode {$/;"	s
dirent	fs.h	/^struct dirent {$/;"	s
dirfile	usertests.c	/^dirfile(void)$/;"	f
dirlink	fs.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f
dirlookup	fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f
dirtest	usertests.c	/^void dirtest(void)$/;"	f
disksize	memide.c	/^static int disksize;$/;"	v	file:
dispatch	message.c	/^void dispatch(int pid, int msg_index)$/;"	f
dlen	sound.h	/^  uint dlen;$/;"	m	struct:wav
dmask	huffman.c	/^HUFFBITS dmask = 1 << (sizeof(HUFFBITS)*8-1);$/;"	v
double_click	clickable.h	/^	Clickable *double_click;$/;"	m	struct:ClickableManager
dpl	mmu.h	/^  uint dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedesc
dpl	mmu.h	/^  uint dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segdesc
drawArea	window.c	/^void drawArea(WindowLink pWindow, color16* context, int x1, int y1, int x2, int y2)$/;"	f
drawFinderContent	finder.c	/^void drawFinderContent(Context context) {$/;"	f
drawFinderWnd	finder.c	/^void drawFinderWnd(Context context) {$/;"	f
drawItem	finder.c	/^void drawItem(Context context, char *name, struct stat st, Rect rect, int chosen) {$/;"	f
drawMouse	window.c	/^void drawMouse(int x, int y)$/;"	f
drawScreen	window.c	/^void drawScreen()$/;"	f
drawScreenArea	window.c	/^void drawScreenArea(int x1, int y1, int x2, int y2)$/;"	f
drawWindow	window.c	/^void drawWindow(WindowLink pWindow, color16* context)$/;"	f
draw_iconlist	drawingAPI.c	/^void draw_iconlist(Context c, ICON* iconlist, int len)$/;"	f
draw_line	drawingAPI.c	/^void draw_line(Context c, int x0, int y0, int x1, int y1, unsigned short color)$/;"	f
draw_picture	drawingAPI.c	/^void draw_picture(Context c, PICNODE pic, int x, int y)$/;"	f
draw_point	drawingAPI.c	/^draw_point(struct Context c, unsigned int x, unsigned int y, unsigned short color)$/;"	f
draw_window	drawingAPI.c	/^draw_window(Context c, char *title)$/;"	f
ds	mmu.h	/^  ushort ds;$/;"	m	struct:taskstate
ds	x86.h	/^  ushort ds;$/;"	m	struct:trapframe
dst	.asm	/^  dst = vdst;$/;"	d
dst	cat.asm	/^  dst = vdst;$/;"	d
dst	decode.asm	/^  dst = vdst;$/;"	d
dst	echo.asm	/^  dst = vdst;$/;"	d
dst	forktest.asm	/^  dst = vdst;$/;"	d
dst	grep.asm	/^  dst = vdst;$/;"	d
dst	init.asm	/^  dst = vdst;$/;"	d
dst	kill.asm	/^  dst = vdst;$/;"	d
dst	ln.asm	/^  dst = vdst;$/;"	d
dst	ls.asm	/^  dst = vdst;$/;"	d
dst	mkdir.asm	/^  dst = vdst;$/;"	d
dst	pause.asm	/^  dst = vdst;$/;"	d
dst	play.asm	/^  dst = vdst;$/;"	d
dx	.asm	/^		dx = (x1 > x0) ? 1024 : -1024;$/;"	d
dx	.asm	/^		dx = (x1 >= x0) ? (((x1 - x0 + 1) << 10) \/ len) : (((x1 - x0 - 1) << 10) \/ len);$/;"	d
dx	.asm	/^	dx = (dx < 0) ? -dx : dx;$/;"	d
dx	.asm	/^	dx = x1 - x0;$/;"	d
dy	.asm	/^		dy = (y1 > y0) ? 1024 : -1024;$/;"	d
dy	.asm	/^		dy = (y1 >= y0) ? (((y1 - y0 + 1) << 10) \/ len) : (((y1 - y0 - 1) << 10) \/ len);$/;"	d
dy	.asm	/^	dy = (dy < 0) ? -dy : dy;$/;"	d
dy	.asm	/^	dy = y1 - y0;$/;"	d
e	.asm	/^       e:	e8 88 40 00 00       	call   409b <malloc>$/;"	l
e	console.c	/^	uint e;  \/\/ Edit index$/;"	m	struct:__anon9	file:
e	decode.asm	/^   e:	90                   	nop$/;"	l
e0	kill.asm	/^  e0:	38 c2                	cmp    %al,%dl$/;"	l
e0	mkdir.asm	/^  e0:	eb 08                	jmp    ea <strcmp+0xd>$/;"	l
e00	.asm	/^     e00:	c7 44 24 04 d5 41 00 	movl   $0x41d5,0x4(%esp)$/;"	l
e07	.asm	/^     e07:	00 $/;"	l
e08	.asm	/^     e08:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)$/;"	l
e0f	.asm	/^     e0f:	e8 a3 2f 00 00       	call   3db7 <printf>$/;"	l
e1	.asm	/^      e1:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
e1	echo.asm	/^  e1:	0f b6 00             	movzbl (%eax),%eax$/;"	l
e14	.asm	/^     e14:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
e17	.asm	/^     e17:	8b 40 2c             	mov    0x2c(%eax),%eax$/;"	l
e1a	.asm	/^     e1a:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
e1d	.asm	/^     e1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
e2	cat.asm	/^  e2:	8b 44 24 18          	mov    0x18(%esp),%eax$/;"	l
e2	grep.asm	/^  e2:	81 c2 a0 0e 00 00    	add    $0xea0,%edx$/;"	l
e2	kill.asm	/^  e2:	74 de                	je     c2 <strcmp+0x5>$/;"	l
e2	ln.asm	/^  e2:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e2	mkdir.asm	/^  e2:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
e21	.asm	/^     e21:	75 d3                	jne    df6 <printItemList+0x10>$/;"	l
e23	.asm	/^     e23:	c9                   	leave  $/;"	l
e24	.asm	/^     e24:	c3                   	ret    $/;"	l
e25	.asm	/^     e25:	55                   	push   %ebp$/;"	l
e26	.asm	/^     e26:	89 e5                	mov    %esp,%ebp$/;"	l
e28	.asm	/^     e28:	83 ec 48             	sub    $0x48,%esp$/;"	l
e2b	.asm	/^     e2b:	a1 64 51 00 00       	mov    0x5164,%eax$/;"	l
e3	decode.asm	/^  e3:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e3	pause.asm	/^  e3:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e30	.asm	/^     e30:	83 f8 01             	cmp    $0x1,%eax$/;"	l
e33	.asm	/^     e33:	0f 85 82 00 00 00    	jne    ebb <getPos+0x96>$/;"	l
e39	.asm	/^     e39:	8b 4d 10             	mov    0x10(%ebp),%ecx$/;"	l
e3c	.asm	/^     e3c:	ba 7f e0 07 7e       	mov    $0x7e07e07f,%edx$/;"	l
e4	.asm	/^      e4:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
e4	echo.asm	/^  e4:	38 c2                	cmp    %al,%dl$/;"	l
e4	forktest.asm	/^  e4:	e8 17 ff ff ff       	call   0 <printf>$/;"	l
e4	init.asm	/^  e4:	00 $/;"	l
e4	kill.asm	/^  e4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e4	ls.asm	/^  e4:	00 $/;"	l
e41	.asm	/^     e41:	89 c8                	mov    %ecx,%eax$/;"	l
e43	.asm	/^     e43:	f7 ea                	imul   %edx$/;"	l
e45	.asm	/^     e45:	c1 fa 06             	sar    $0x6,%edx$/;"	l
e48	.asm	/^     e48:	89 c8                	mov    %ecx,%eax$/;"	l
e4a	.asm	/^     e4a:	c1 f8 1f             	sar    $0x1f,%eax$/;"	l
e4d	.asm	/^     e4d:	89 d1                	mov    %edx,%ecx$/;"	l
e4f	.asm	/^     e4f:	29 c1                	sub    %eax,%ecx$/;"	l
e5	init.asm	/^  e5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
e5	ln.asm	/^  e5:	0f b6 00             	movzbl (%eax),%eax$/;"	l
e5	ls.asm	/^  e5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)$/;"	l
e5	play.asm	/^  e5:	00 $/;"	l
e51	.asm	/^     e51:	89 c8                	mov    %ecx,%eax$/;"	l
e53	.asm	/^     e53:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
e56	.asm	/^     e56:	8b 45 18             	mov    0x18(%ebp),%eax$/;"	l
e59	.asm	/^     e59:	89 c2                	mov    %eax,%edx$/;"	l
e5b	.asm	/^     e5b:	c1 fa 1f             	sar    $0x1f,%edx$/;"	l
e5e	.asm	/^     e5e:	f7 7d f4             	idivl  -0xc(%ebp)$/;"	l
e6	cat.asm	/^  e6:	89 04 24             	mov    %eax,(%esp)$/;"	l
e6	decode.asm	/^  e6:	89 04 24             	mov    %eax,(%esp)$/;"	l
e6	echo.asm	/^  e6:	74 de                	je     c6 <strcmp+0x5>$/;"	l
e6	mkdir.asm	/^  e6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
e6	pause.asm	/^  e6:	89 04 24             	mov    %eax,(%esp)$/;"	l
e6	play.asm	/^  e6:	66 83 f8 10          	cmp    $0x10,%ax$/;"	l
e61	.asm	/^     e61:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
e64	.asm	/^     e64:	8b 45 18             	mov    0x18(%ebp),%eax$/;"	l
e67	.asm	/^     e67:	89 c2                	mov    %eax,%edx$/;"	l
e69	.asm	/^     e69:	c1 fa 1f             	sar    $0x1f,%edx$/;"	l
e6c	.asm	/^     e6c:	f7 7d f4             	idivl  -0xc(%ebp)$/;"	l
e6f	.asm	/^     e6f:	89 55 ec             	mov    %edx,-0x14(%ebp)$/;"	l
e7	.asm	/^      e7:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
e7	kill.asm	/^  e7:	0f b6 00             	movzbl (%eax),%eax$/;"	l
e72	.asm	/^     e72:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
e75	.asm	/^     e75:	6b c0 73             	imul   $0x73,%eax,%eax$/;"	l
e78	.asm	/^     e78:	83 c0 5a             	add    $0x5a,%eax$/;"	l
e7b	.asm	/^     e7b:	89 45 e8             	mov    %eax,-0x18(%ebp)$/;"	l
e7e	.asm	/^     e7e:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
e8	echo.asm	/^  e8:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e8	grep.asm	/^  e8:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
e8	ln.asm	/^  e8:	84 c0                	test   %al,%al$/;"	l
e81	.asm	/^     e81:	01 c0                	add    %eax,%eax$/;"	l
e83	.asm	/^     e83:	89 c2                	mov    %eax,%edx$/;"	l
e85	.asm	/^     e85:	c1 e2 06             	shl    $0x6,%edx$/;"	l
e88	.asm	/^     e88:	01 d0                	add    %edx,%eax$/;"	l
e8a	.asm	/^     e8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)$/;"	l
e8d	.asm	/^     e8d:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e9	cat.asm	/^  e9:	e8 12 ff ff ff       	call   0 <cat>$/;"	l
e9	decode.asm	/^  e9:	e8 22 ff ff ff       	call   10 <stosb>$/;"	l
e9	forktest.asm	/^  e9:	e8 8a 02 00 00       	call   378 <exit>$/;"	l
e9	pause.asm	/^  e9:	e8 22 ff ff ff       	call   10 <stosb>$/;"	l
e90	.asm	/^     e90:	c7 44 24 10 5f 00 00 	movl   $0x5f,0x10(%esp)$/;"	l
e97	.asm	/^     e97:	00 $/;"	l
e98	.asm	/^     e98:	c7 44 24 0c 64 00 00 	movl   $0x64,0xc(%esp)$/;"	l
e9f	.asm	/^     e9f:	00 $/;"	l
ea	.asm	/^      ea:	8b 40 2c             	mov    0x2c(%eax),%eax$/;"	l
ea	kill.asm	/^  ea:	0f b6 d0             	movzbl %al,%edx$/;"	l
ea	ln.asm	/^  ea:	74 10                	je     fc <strcmp+0x27>$/;"	l
ea	mkdir.asm	/^  ea:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ea	play.asm	/^  ea:	74 28                	je     114 <main+0x114>$/;"	l
ea0	.asm	/^     ea0:	8b 55 e8             	mov    -0x18(%ebp),%edx$/;"	l
ea3	.asm	/^     ea3:	89 54 24 08          	mov    %edx,0x8(%esp)$/;"	l
ea7	.asm	/^     ea7:	8b 55 e4             	mov    -0x1c(%ebp),%edx$/;"	l
eaa	.asm	/^     eaa:	89 54 24 04          	mov    %edx,0x4(%esp)$/;"	l
eae	.asm	/^     eae:	89 04 24             	mov    %eax,(%esp)$/;"	l
eargv	sh.c	/^  char *eargv[MAXARGS];$/;"	m	struct:execcmd	file:
eax	mmu.h	/^  uint eax;          \/\/ More saved state (registers)$/;"	m	struct:taskstate
eax	x86.h	/^  uint eax;$/;"	m	struct:trapframe
eb	echo.asm	/^  eb:	0f b6 00             	movzbl (%eax),%eax$/;"	l
eb1	.asm	/^     eb1:	e8 45 24 00 00       	call   32fb <initRect>$/;"	l
eb6	.asm	/^     eb6:	83 ec 04             	sub    $0x4,%esp$/;"	l
eb9	.asm	/^     eb9:	eb 36                	jmp    ef1 <getPos+0xcc>$/;"	l
ebb	.asm	/^     ebb:	8b 4d 10             	mov    0x10(%ebp),%ecx$/;"	l
ebe	.asm	/^     ebe:	8b 55 18             	mov    0x18(%ebp),%edx$/;"	l
ebp	mmu.h	/^  uint *ebp;$/;"	m	struct:taskstate
ebp	proc.h	/^  uint ebp;$/;"	m	struct:context
ebp	x86.h	/^  uint ebp;$/;"	m	struct:trapframe
ebx	mmu.h	/^  uint ebx;$/;"	m	struct:taskstate
ebx	proc.h	/^  uint ebx;$/;"	m	struct:context
ebx	x86.h	/^  uint ebx;$/;"	m	struct:trapframe
ec	grep.asm	/^  ec:	89 54 24 04          	mov    %edx,0x4(%esp)$/;"	l
ec	init.asm	/^  ec:	e8 da 04 00 00       	call   5cb <printf>$/;"	l
ec	ln.asm	/^  ec:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ec	ls.asm	/^  ec:	e8 a6 06 00 00       	call   797 <printf>$/;"	l
ec	play.asm	/^  ec:	c7 44 24 04 3c 0b 00 	movl   $0xb3c,0x4(%esp)$/;"	l
ec1	.asm	/^     ec1:	89 d0                	mov    %edx,%eax$/;"	l
ec3	.asm	/^     ec3:	c1 e0 05             	shl    $0x5,%eax$/;"	l
ec6	.asm	/^     ec6:	29 d0                	sub    %edx,%eax$/;"	l
ec8	.asm	/^     ec8:	8d 50 62             	lea    0x62(%eax),%edx$/;"	l
ecb	.asm	/^     ecb:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ece	.asm	/^     ece:	c7 44 24 10 1e 00 00 	movl   $0x1e,0x10(%esp)$/;"	l
echoargv	usertests.c	/^char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };$/;"	v
ecx	mmu.h	/^  uint ecx;$/;"	m	struct:taskstate
ecx	x86.h	/^  uint ecx;$/;"	m	struct:trapframe
ed	.asm	/^      ed:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
ed	kill.asm	/^  ed:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ed	mkdir.asm	/^  ed:	0f b6 00             	movzbl (%eax),%eax$/;"	l
ed5	.asm	/^     ed5:	00 $/;"	l
ed6	.asm	/^     ed6:	89 4c 24 0c          	mov    %ecx,0xc(%esp)$/;"	l
eda	.asm	/^     eda:	89 54 24 08          	mov    %edx,0x8(%esp)$/;"	l
ede	.asm	/^     ede:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
edi	mmu.h	/^  uint edi;$/;"	m	struct:taskstate
edi	proc.h	/^  uint edi;$/;"	m	struct:context
edi	x86.h	/^  uint edi;$/;"	m	struct:trapframe
edx	mmu.h	/^  uint edx;$/;"	m	struct:taskstate
edx	x86.h	/^  uint edx;$/;"	m	struct:trapframe
ee	cat.asm	/^  ee:	8b 44 24 18          	mov    0x18(%esp),%eax$/;"	l
ee	decode.asm	/^  ee:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ee	echo.asm	/^  ee:	0f b6 d0             	movzbl %al,%edx$/;"	l
ee	forktest.asm	/^  ee:	c7 44 24 04 d2 04 00 	movl   $0x4d2,0x4(%esp)$/;"	l
ee	pause.asm	/^  ee:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ee5	.asm	/^     ee5:	00 $/;"	l
ee6	.asm	/^     ee6:	89 04 24             	mov    %eax,(%esp)$/;"	l
ee9	.asm	/^     ee9:	e8 0d 24 00 00       	call   32fb <initRect>$/;"	l
eee	.asm	/^     eee:	83 ec 04             	sub    $0x4,%esp$/;"	l
ef	ln.asm	/^  ef:	0f b6 10             	movzbl (%eax),%edx$/;"	l
ef1	.asm	/^     ef1:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ef4	.asm	/^     ef4:	c9                   	leave  $/;"	l
ef5	.asm	/^     ef5:	c2 04 00             	ret    $0x4$/;"	l
ef8	.asm	/^     ef8:	55                   	push   %ebp$/;"	l
ef9	.asm	/^     ef9:	89 e5                	mov    %esp,%ebp$/;"	l
efb	.asm	/^     efb:	83 ec 28             	sub    $0x28,%esp$/;"	l
efe	.asm	/^     efe:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax$/;"	l
efile	sh.c	/^  char *efile;$/;"	m	struct:redircmd	file:
eflags	mmu.h	/^  uint eflags;$/;"	m	struct:taskstate
eflags	x86.h	/^  uint eflags;$/;"	m	struct:trapframe
ehsize	elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr
eip	mmu.h	/^  uint *eip;         \/\/ Saved state from last task switch$/;"	m	struct:taskstate
eip	proc.h	/^  uint eip;$/;"	m	struct:context
eip	x86.h	/^  uint eip;$/;"	m	struct:trapframe
elf	elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr
elfhdr	elf.h	/^struct elfhdr {$/;"	s
emphasis	common.h	/^    int emphasis;$/;"	m	struct:__anon13
end_bs	common.c	/^int end_bs(Bit_stream_struc *bs)$/;"	f
end_op	log.c	/^end_op(void)$/;"	f
enterDir	finder.c	/^void enterDir(char *name) {$/;"	f
entry	elf.h	/^  uint entry;$/;"	m	struct:elfhdr
entry	entry.S	/^entry:$/;"	l
entry	mp.h	/^  ushort entry;                 \/\/ entry count$/;"	m	struct:mpconf
entrypgdir	main.c	/^pde_t entrypgdir[NPDENTRIES] = {$/;"	v
entrypgdir	main.c	/^pde_t entrypgdir[];  \/\/ For entry.S$/;"	v
eob	common.h	/^    int         eob;            \/*  *\/$/;"	m	struct:bit_stream_struc
eobs	common.h	/^    int         eobs;           \/* ־ *\/$/;"	m	struct:bit_stream_struc
err	x86.h	/^  uint err;$/;"	m	struct:trapframe
error_protection	common.h	/^    int error_protection;$/;"	m	struct:__anon13
es	mmu.h	/^  ushort es;         \/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate
es	x86.h	/^  ushort es;$/;"	m	struct:trapframe
esi	mmu.h	/^  uint esi;$/;"	m	struct:taskstate
esi	proc.h	/^  uint esi;$/;"	m	struct:context
esi	x86.h	/^  uint esi;$/;"	m	struct:trapframe
esp	mmu.h	/^  uint *esp;$/;"	m	struct:taskstate
esp	x86.h	/^  uint esp;$/;"	m	struct:trapframe
esp0	mmu.h	/^  uint esp0;         \/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate
esp1	mmu.h	/^  uint *esp1;$/;"	m	struct:taskstate
esp2	mmu.h	/^  uint *esp2;$/;"	m	struct:taskstate
event	mouse.c	/^static int event = 0;$/;"	v	file:
exec	exec.c	/^exec(char *path, char **argv)$/;"	f
execcmd	sh.c	/^execcmd(void)$/;"	f
execcmd	sh.c	/^struct execcmd {$/;"	s	file:
exectest	usertests.c	/^exectest(void)$/;"	f
executeHandler	clickable.c	/^int executeHandler(Clickable *head, Point click)$/;"	f
exit	initcode.S	/^exit:$/;"	l
exit	proc.c	/^exit(void)$/;"	f
exitiputtest	usertests.c	/^exitiputtest(void)$/;"	f
exitwait	usertests.c	/^exitwait(void)$/;"	f
exp	math.c	/^double exp( double x )$/;"	f
extension	common.h	/^    int extension;$/;"	m	struct:__anon13
f	Makefile	/^	dd if=\/dev\/zero of=xv6.img count=120000$/;"	m
f	Makefile	/^	dd if=\/dev\/zero of=xv6memfs.img count=10000$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6memfs.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernel of=xv6.img seek=1 conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc$/;"	m
f	cat.asm	/^   f:	c7 44 24 04 e0 0b 00 	movl   $0xbe0,0x4(%esp)$/;"	l
f	decode.asm	/^   f:	90                   	nop$/;"	l
f	kill.asm	/^   f:	c7 44 24 04 6b 08 00 	movl   $0x86b,0x4(%esp)$/;"	l
f	ln.asm	/^   f:	c7 44 24 04 83 08 00 	movl   $0x883,0x4(%esp)$/;"	l
f	mkdir.asm	/^   f:	c7 44 24 04 8b 08 00 	movl   $0x88b,0x4(%esp)$/;"	l
f	play.asm	/^   f:	83 c0 04             	add    $0x4,%eax$/;"	l
f0	.asm	/^      f0:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
f0	grep.asm	/^  f0:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f0	kill.asm	/^  f0:	0f b6 00             	movzbl (%eax),%eax$/;"	l
f0	mkdir.asm	/^  f0:	84 c0                	test   %al,%al$/;"	l
f02	.asm	/^     f02:	98                   	cwtl   $/;"	l
f03	.asm	/^     f03:	83 f8 01             	cmp    $0x1,%eax$/;"	l
f06	.asm	/^     f06:	74 45                	je     f4d <addItemEvent+0x55>$/;"	l
f08	.asm	/^     f08:	83 f8 02             	cmp    $0x2,%eax$/;"	l
f0b	.asm	/^     f0b:	0f 85 ac 00 00 00    	jne    fbd <addItemEvent+0xc5>$/;"	l
f1	decode.asm	/^  f1:	c9                   	leave  $/;"	l
f1	echo.asm	/^  f1:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f1	init.asm	/^  f1:	e8 ee 02 00 00       	call   3e4 <fork>$/;"	l
f1	ls.asm	/^  f1:	e9 01 02 00 00       	jmp    2f7 <ls+0x249>$/;"	l
f1	pause.asm	/^  f1:	c9                   	leave  $/;"	l
f11	.asm	/^     f11:	c7 44 24 18 e8 16 00 	movl   $0x16e8,0x18(%esp)$/;"	l
f18	.asm	/^     f18:	00 $/;"	l
f19	.asm	/^     f19:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)$/;"	l
f2	cat.asm	/^  f2:	89 04 24             	mov    %eax,(%esp)$/;"	l
f2	decode.asm	/^  f2:	c3                   	ret    $/;"	l
f2	ln.asm	/^  f2:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f2	mkdir.asm	/^  f2:	74 10                	je     104 <strcmp+0x27>$/;"	l
f2	pause.asm	/^  f2:	c3                   	ret    $/;"	l
f20	.asm	/^     f20:	00 $/;"	l
f21	.asm	/^     f21:	8b 45 24             	mov    0x24(%ebp),%eax$/;"	l
f24	.asm	/^     f24:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
f28	.asm	/^     f28:	8b 45 28             	mov    0x28(%ebp),%eax$/;"	l
f2b	.asm	/^     f2b:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
f2f	.asm	/^     f2f:	8b 45 2c             	mov    0x2c(%ebp),%eax$/;"	l
f3	.asm	/^      f3:	8b 40 14             	mov    0x14(%eax),%eax$/;"	l
f3	decode.asm	/^  f3:	55                   	push   %ebp$/;"	l
f3	grep.asm	/^  f3:	89 04 24             	mov    %eax,(%esp)$/;"	l
f3	kill.asm	/^  f3:	0f b6 c0             	movzbl %al,%eax$/;"	l
f3	pause.asm	/^  f3:	55                   	push   %ebp$/;"	l
f3	play.asm	/^  f3:	00 $/;"	l
f32	.asm	/^     f32:	89 44 24 0c          	mov    %eax,0xc(%esp)$/;"	l
f36	.asm	/^     f36:	8b 45 30             	mov    0x30(%ebp),%eax$/;"	l
f39	.asm	/^     f39:	89 44 24 10          	mov    %eax,0x10(%esp)$/;"	l
f3d	.asm	/^     f3d:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f4	decode.asm	/^  f4:	89 e5                	mov    %esp,%ebp$/;"	l
f4	echo.asm	/^  f4:	0f b6 00             	movzbl (%eax),%eax$/;"	l
f4	mkdir.asm	/^  f4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f4	pause.asm	/^  f4:	89 e5                	mov    %esp,%ebp$/;"	l
f4	play.asm	/^  f4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)$/;"	l
f40	.asm	/^     f40:	89 04 24             	mov    %eax,(%esp)$/;"	l
f43	.asm	/^     f43:	e8 9f 24 00 00       	call   33e7 <createClickable>$/;"	l
f48	.asm	/^     f48:	e9 84 00 00 00       	jmp    fd1 <addItemEvent+0xd9>$/;"	l
f4d	.asm	/^     f4d:	c7 44 24 18 e8 16 00 	movl   $0x16e8,0x18(%esp)$/;"	l
f5	cat.asm	/^  f5:	e8 a2 02 00 00       	call   39c <close>$/;"	l
f5	forktest.asm	/^  f5:	00 $/;"	l
f5	ln.asm	/^  f5:	0f b6 00             	movzbl (%eax),%eax$/;"	l
f54	.asm	/^     f54:	00 $/;"	l
f55	.asm	/^     f55:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)$/;"	l
f5c	.asm	/^     f5c:	00 $/;"	l
f5d	.asm	/^     f5d:	8b 45 24             	mov    0x24(%ebp),%eax$/;"	l
f6	.asm	/^      f6:	89 04 24             	mov    %eax,(%esp)$/;"	l
f6	decode.asm	/^  f6:	83 ec 04             	sub    $0x4,%esp$/;"	l
f6	forktest.asm	/^  f6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
f6	grep.asm	/^  f6:	e8 d1 04 00 00       	call   5cc <read>$/;"	l
f6	init.asm	/^  f6:	89 44 24 18          	mov    %eax,0x18(%esp)$/;"	l
f6	kill.asm	/^  f6:	89 d1                	mov    %edx,%ecx$/;"	l
f6	ls.asm	/^  f6:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax$/;"	l
f6	pause.asm	/^  f6:	83 ec 04             	sub    $0x4,%esp$/;"	l
f60	.asm	/^     f60:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
f64	.asm	/^     f64:	8b 45 28             	mov    0x28(%ebp),%eax$/;"	l
f67	.asm	/^     f67:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
f6b	.asm	/^     f6b:	8b 45 2c             	mov    0x2c(%ebp),%eax$/;"	l
f6e	.asm	/^     f6e:	89 44 24 0c          	mov    %eax,0xc(%esp)$/;"	l
f7	echo.asm	/^  f7:	0f b6 c0             	movzbl %al,%eax$/;"	l
f7	mkdir.asm	/^  f7:	0f b6 10             	movzbl (%eax),%edx$/;"	l
f72	.asm	/^     f72:	8b 45 30             	mov    0x30(%ebp),%eax$/;"	l
f75	.asm	/^     f75:	89 44 24 10          	mov    %eax,0x10(%esp)$/;"	l
f79	.asm	/^     f79:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f7c	.asm	/^     f7c:	89 04 24             	mov    %eax,(%esp)$/;"	l
f7f	.asm	/^     f7f:	e8 63 24 00 00       	call   33e7 <createClickable>$/;"	l
f8	kill.asm	/^  f8:	29 c1                	sub    %eax,%ecx$/;"	l
f8	ln.asm	/^  f8:	38 c2                	cmp    %al,%dl$/;"	l
f84	.asm	/^     f84:	c7 44 24 18 ce 11 00 	movl   $0x11ce,0x18(%esp)$/;"	l
f8b	.asm	/^     f8b:	00 $/;"	l
f8c	.asm	/^     f8c:	c7 44 24 14 04 00 00 	movl   $0x4,0x14(%esp)$/;"	l
f9	.asm	/^      f9:	e8 6e 3e 00 00       	call   3f6c <free>$/;"	l
f9	decode.asm	/^  f9:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f9	pause.asm	/^  f9:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f93	.asm	/^     f93:	00 $/;"	l
f94	.asm	/^     f94:	8b 45 24             	mov    0x24(%ebp),%eax$/;"	l
f97	.asm	/^     f97:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
f9b	.asm	/^     f9b:	8b 45 28             	mov    0x28(%ebp),%eax$/;"	l
f9e	.asm	/^     f9e:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
fa	cat.asm	/^  fa:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)$/;"	l
fa	echo.asm	/^  fa:	89 d1                	mov    %edx,%ecx$/;"	l
fa	init.asm	/^  fa:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)$/;"	l
fa	kill.asm	/^  fa:	89 c8                	mov    %ecx,%eax$/;"	l
fa	ln.asm	/^  fa:	74 de                	je     da <strcmp+0x5>$/;"	l
fa	mkdir.asm	/^  fa:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
fa2	.asm	/^     fa2:	8b 45 2c             	mov    0x2c(%ebp),%eax$/;"	l
fa5	.asm	/^     fa5:	89 44 24 0c          	mov    %eax,0xc(%esp)$/;"	l
fa9	.asm	/^     fa9:	8b 45 30             	mov    0x30(%ebp),%eax$/;"	l
fac	.asm	/^     fac:	89 44 24 10          	mov    %eax,0x10(%esp)$/;"	l
fb	grep.asm	/^  fb:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
fb	play.asm	/^  fb:	e8 4b 06 00 00       	call   74b <printf>$/;"	l
fb0	.asm	/^     fb0:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
fb3	.asm	/^     fb3:	89 04 24             	mov    %eax,(%esp)$/;"	l
fb6	.asm	/^     fb6:	e8 2c 24 00 00       	call   33e7 <createClickable>$/;"	l
fbb	.asm	/^     fbb:	eb 14                	jmp    fd1 <addItemEvent+0xd9>$/;"	l
fbd	.asm	/^     fbd:	c7 44 24 04 d9 41 00 	movl   $0x41d9,0x4(%esp)$/;"	l
fc	decode.asm	/^  fc:	88 45 fc             	mov    %al,-0x4(%ebp)$/;"	l
fc	echo.asm	/^  fc:	29 c1                	sub    %eax,%ecx$/;"	l
fc	kill.asm	/^  fc:	5d                   	pop    %ebp$/;"	l
fc	ln.asm	/^  fc:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
fc	ls.asm	/^  fc:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
fc	pause.asm	/^  fc:	88 45 fc             	mov    %al,-0x4(%ebp)$/;"	l
fc4	.asm	/^     fc4:	00 $/;"	l
fc5	.asm	/^     fc5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)$/;"	l
fcc	.asm	/^     fcc:	e8 e6 2d 00 00       	call   3db7 <printf>$/;"	l
fd	.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	cat.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	decode.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	echo.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	forktest.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	forktest.asm	/^  fd:	e8 fe fe ff ff       	call   0 <printf>$/;"	l
fd	grep.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	init.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	kill.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	kill.asm	/^  fd:	c3                   	ret    $/;"	l
fd	ln.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	ls.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	mkdir.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	mkdir.asm	/^  fd:	0f b6 00             	movzbl (%eax),%eax$/;"	l
fd	pause.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	play.asm	/^  fd = open(argv[1], O_RDWR);$/;"	d
fd	play.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	sh.c	/^  int fd;$/;"	m	struct:redircmd	file:
fd1	.asm	/^     fd1:	c9                   	leave  $/;"	l
fd2	.asm	/^     fd2:	c3                   	ret    $/;"	l
fd3	.asm	/^     fd3:	55                   	push   %ebp$/;"	l
fd4	.asm	/^     fd4:	89 e5                	mov    %esp,%ebp$/;"	l
fd6	.asm	/^     fd6:	83 ec 58             	sub    $0x58,%esp$/;"	l
fd9	.asm	/^     fd9:	a1 40 54 00 00       	mov    0x5440,%eax$/;"	l
fdalloc	sysfile.c	/^fdalloc(struct file *f)$/;"	f	file:
fde	.asm	/^     fde:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
fe	.asm	/^      fe:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
fe	echo.asm	/^  fe:	89 c8                	mov    %ecx,%eax$/;"	l
fe	grep.asm	/^  fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)$/;"	l
fe	kill.asm	/^  fe:	55                   	push   %ebp$/;"	l
fe1	.asm	/^     fe1:	eb 70                	jmp    1053 <addListEvent+0x80>$/;"	l
fe3	.asm	/^     fe3:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
fe6	.asm	/^     fe6:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
fe9	.asm	/^     fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
feature	mp.h	/^  uint feature;                 \/\/ feature flags from CPUID instruction$/;"	m	struct:mpproc
fec	.asm	/^     fec:	8b 40 2c             	mov    0x2c(%eax),%eax$/;"	l
fef	.asm	/^     fef:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
fetchint	syscall.c	/^fetchint(uint addr, int *ip)$/;"	f
fetchstr	syscall.c	/^fetchstr(uint addr, char **pp)$/;"	f
ff	cat.asm	/^  ff:	8b 44 24 1c          	mov    0x1c(%esp),%eax$/;"	l
ff	decode.asm	/^  ff:	eb 14                	jmp    115 <strchr+0x22>$/;"	l
ff	init.asm	/^  ff:	79 19                	jns    11a <main+0x11a>$/;"	l
ff	kill.asm	/^  ff:	89 e5                	mov    %esp,%ebp$/;"	l
ff	ln.asm	/^  ff:	0f b6 00             	movzbl (%eax),%eax$/;"	l
ff	pause.asm	/^  ff:	eb 14                	jmp    115 <strchr+0x22>$/;"	l
ff2	.asm	/^     ff2:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ff5	.asm	/^     ff5:	8b 10                	mov    (%eax),%edx$/;"	l
ff7	.asm	/^     ff7:	89 54 24 04          	mov    %edx,0x4(%esp)$/;"	l
ffb	.asm	/^     ffb:	8b 50 04             	mov    0x4(%eax),%edx$/;"	l
ffe	.asm	/^     ffe:	89 54 24 08          	mov    %edx,0x8(%esp)$/;"	l
file	file.c	/^  struct file file[NFILE];$/;"	m	struct:__anon5	typeref:struct:__anon5::file	file:
file	file.h	/^struct file {$/;"	s
file	sh.c	/^  char *file;$/;"	m	struct:redircmd	file:
fileItem	finder.c	/^struct fileItem {$/;"	s	file:
fileItemList	.asm	/^	fileItemList = 0;$/;"	d
fileItemList	.asm	/^	fileItemList = temp;$/;"	d
fileItemList	finder.c	/^struct fileItem *fileItemList = 0;$/;"	v	typeref:struct:fileItem
filealloc	file.c	/^filealloc(void)$/;"	f
fileclose	file.c	/^fileclose(struct file *f)$/;"	f
filedup	file.c	/^filedup(struct file *f)$/;"	f
fileinit	file.c	/^fileinit(void)$/;"	f
fileread	file.c	/^fileread(struct file *f, char *addr, int n)$/;"	f
filestat	file.c	/^filestat(struct file *f, struct stat *st)$/;"	f
filesz	elf.h	/^  uint filesz;$/;"	m	struct:proghdr
filewrite	file.c	/^filewrite(struct file *f, char *addr, int n)$/;"	f
fill_rect	drawingAPI.c	/^fill_rect(struct Context c, unsigned int bx, unsigned int by, unsigned int width, unsigned int height, unsigned short color)$/;"	f
fill_rtcdate	lapic.c	/^static void fill_rtcdate(struct rtcdate *r)$/;"	f	file:
findcmd	sh.c	/^findcmd(char *cmd)$/;"	f
finderinit	desktop.c	/^int finderinit(Point point)$/;"	f
first_msg	message.h	/^	int first_msg;\/\/待处理的第一个消息在全局消息队列中的索引$/;"	m	struct:MsgTableEntry
flag	sound.h	/^  volatile int flag;$/;"	m	struct:soundNode
flag_caps	kbd.c	/^static int flag_caps = 0;$/;"	v	file:
flag_shift	kbd.c	/^static int flag_shift = 0;$/;"	v	file:
flags	buf.h	/^  int flags;$/;"	m	struct:buf
flags	elf.h	/^  uint flags;$/;"	m	struct:elfhdr
flags	elf.h	/^  uint flags;$/;"	m	struct:proghdr
flags	file.h	/^  int flags;          \/\/ I_BUSY, I_VALID$/;"	m	struct:inode
flags	mp.h	/^  uchar flags;                  \/\/ CPU flags$/;"	m	struct:mpproc
flags	mp.h	/^  uchar flags;                  \/\/ I\/O APIC flags$/;"	m	struct:mpioapic
fmt	sound.h	/^struct fmt {$/;"	s
fmtname	cp.c	/^char* fmtname(char *path)$/;"	f
fmtname	finder.c	/^char* fmtname(char *path) {$/;"	f
fmtname	ls.c	/^fmtname(char *path)$/;"	f
fmtname	mv.c	/^char* fmtname(char *path)$/;"	f
fontFile	drawingAPI.c	/^struct File_Node fontFile;$/;"	v	typeref:struct:File_Node
fork	proc.c	/^fork(void)$/;"	f
fork1	sh.c	/^fork1(void)$/;"	f
forkret	proc.c	/^forkret(void)$/;"	f
forktest	forktest.c	/^forktest(void)$/;"	f
forktest	usertests.c	/^forktest(void)$/;"	f
format	common.h	/^    char        format;$/;"	m	struct:bit_stream_struc
fourfiles	usertests.c	/^fourfiles(void)$/;"	f
fourteen	usertests.c	/^fourteen(void)$/;"	f
fr_ps	sound.h	/^	struct frame_params fr_ps;$/;"	m	struct:coreBuf	typeref:struct:coreBuf::frame_params
frame_params	common.h	/^struct frame_params{$/;"	s
free	umalloc.c	/^free(void *ap)$/;"	f
freeASCII	drawingAPI.c	/^void freeASCII(){$/;"	f
freeFileItemList	finder.c	/^void freeFileItemList() {$/;"	f
freeGBK	drawingAPI.c	/^void freeGBK(){$/;"	f
free_context	context.c	/^void free_context(struct Context* context_ptr, int winid)$/;"	f
freeblock	mkfs.c	/^uint freeblock;$/;"	v
freeinode	mkfs.c	/^uint freeinode = 1;$/;"	v
freelist	kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon8	typeref:struct:__anon8::run	file:
freep	.asm	/^      freep = prevp;$/;"	d
freep	.asm	/^  freep = p;$/;"	d
freep	cat.asm	/^      freep = prevp;$/;"	d
freep	cat.asm	/^  freep = p;$/;"	d
freep	decode.asm	/^      freep = prevp;$/;"	d
freep	decode.asm	/^  freep = p;$/;"	d
freep	echo.asm	/^      freep = prevp;$/;"	d
freep	echo.asm	/^  freep = p;$/;"	d
freep	grep.asm	/^      freep = prevp;$/;"	d
freep	grep.asm	/^  freep = p;$/;"	d
freep	init.asm	/^      freep = prevp;$/;"	d
freep	init.asm	/^  freep = p;$/;"	d
freep	kill.asm	/^      freep = prevp;$/;"	d
freep	kill.asm	/^  freep = p;$/;"	d
freep	ln.asm	/^      freep = prevp;$/;"	d
freep	ln.asm	/^  freep = p;$/;"	d
freep	ls.asm	/^      freep = prevp;$/;"	d
freep	ls.asm	/^  freep = p;$/;"	d
freep	mkdir.asm	/^      freep = prevp;$/;"	d
freep	mkdir.asm	/^  freep = p;$/;"	d
freep	pause.asm	/^      freep = prevp;$/;"	d
freep	pause.asm	/^  freep = p;$/;"	d
freep	play.asm	/^      freep = prevp;$/;"	d
freep	play.asm	/^  freep = p;$/;"	d
freep	umalloc.c	/^static Header *freep;$/;"	v	file:
freepic	bitmap.c	/^void freepic(PICNODE *pic)$/;"	f
freerange	kalloc.c	/^freerange(void *vstart, void *vend)$/;"	f
freevm	vm.c	/^freevm(pde_t *pgdir)$/;"	f
fs	mmu.h	/^  ushort fs;$/;"	m	struct:taskstate
fs	x86.h	/^  ushort fs;$/;"	m	struct:trapframe
fsfd	mkfs.c	/^int fsfd;$/;"	v
fsfull	usertests.c	/^fsfull()$/;"	f
ftable	file.c	/^} ftable;$/;"	v	typeref:struct:__anon5
g	mmu.h	/^  uint g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segdesc
gatedesc	mmu.h	/^struct gatedesc {$/;"	s
gdt	bootasm.S	/^gdt:$/;"	l
gdt	entryother.S	/^gdt:$/;"	l
gdt	proc.h	/^  struct segdesc gdt[NSEGS];   \/\/ x86 global descriptor table$/;"	m	struct:cpu	typeref:struct:cpu::segdesc
gdt	vm.c	/^struct segdesc gdt[NSEGS];$/;"	v	typeref:struct:segdesc
gdtdesc	bootasm.S	/^gdtdesc:$/;"	l
gdtdesc	entryother.S	/^gdtdesc:$/;"	l
get1bit	common.c	/^unsigned int get1bit(Bit_stream_struc *bs)$/;"	f
getActivated	window.c	/^WindowLink getActivated()$/;"	f
getClickedPid	window.c	/^int getClickedPid(int position_x, int position_y)$/;"	f
getFileItem	finder.c	/^struct fileItem * getFileItem(Point point) {$/;"	f
getIntersection	window.c	/^Rect getIntersection(Rect a, Rect b)$/;"	f
getMsg	message.c	/^void getMsg(int pid, struct Msg* ptr)$/;"	f
getPos	finder.c	/^Rect getPos(Context context, int n) {$/;"	f
getUnion	window.c	/^Rect getUnion(Rect a, Rect b)$/;"	f
getWindowById	window.c	/^WindowLink getWindowById(int window_id)$/;"	f
getWindowByPoint	window.c	/^WindowLink getWindowByPoint(int position_x, int position_y)$/;"	f
get_line_number	editor.c	/^int get_line_number(char *text[])$/;"	f
getbits	common.c	/^unsigned long getbits(Bit_stream_struc *bs, int N)$/;"	f
getcallerpcs	spinlock.c	/^getcallerpcs(void *v, uint pcs[])$/;"	f
getcmd	sh.c	/^getcmd(char *buf, int nbuf)$/;"	f
getmatchcmd	console.c	/^getmatchcmd(char matchcmd[][COMMANDMAXLENDTH])$/;"	f
gets	ulib.c	/^gets(char *buf, int max)$/;"	f
gettoken	sh.c	/^gettoken(char **ps, char *es, char **q, char **eq)$/;"	f
global_gain	common.h	/^			unsigned global_gain;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
gr	common.h	/^		} gr[2];$/;"	m	struct:III_side_info_t::__anon14	typeref:struct:III_side_info_t::__anon14::gr_info_s
gr_info_s	common.h	/^		struct gr_info_s {$/;"	s	struct:III_side_info_t::__anon14
grep	grep.c	/^grep(char *pattern, int fd)$/;"	f
growproc	proc.c	/^growproc(int n)$/;"	f
gs	mmu.h	/^  ushort gs;$/;"	m	struct:taskstate
gs	x86.h	/^  ushort gs;$/;"	m	struct:trapframe
h_chooseFile	finder.c	/^void h_chooseFile(Point p) {$/;"	f
h_chvm1	finder.c	/^void h_chvm1(Point p) {$/;"	f
h_chvm2	finder.c	/^void h_chvm2(Point p) {$/;"	f
h_closeWnd	finder.c	/^void h_closeWnd(Point p) {$/;"	f
h_deleteFile	finder.c	/^void h_deleteFile(Point p) {$/;"	f
h_empty	finder.c	/^void h_empty(Point p) {$/;"	f
h_enterDir	finder.c	/^void h_enterDir(Point p) {$/;"	f
h_goUp	finder.c	/^void h_goUp(Point p) {$/;"	f
h_newFile	finder.c	/^void h_newFile(Point p) {$/;"	f
h_newFolder	finder.c	/^void h_newFolder(Point p) {$/;"	f
handler	clickable.h	/^	Handler handler;$/;"	m	struct:Clickable
hankaku	.asm	/^	hankaku = malloc(ASCII_NUM*ASCII_HEIGHT);$/;"	d
hankaku	drawingAPI.c	/^unsigned char *hankaku;$/;"	v
havedisk1	ide.c	/^static int havedisk1;$/;"	v	file:
hdr_to_frps	common.c	/^void hdr_to_frps(struct frame_params *fr_ps)$/;"	f
head	bio.c	/^  struct buf head;$/;"	m	struct:__anon2	typeref:struct:__anon2::buf	file:
header	common.h	/^    layer       *header;        \/* ͷϢ *\/$/;"	m	struct:frame_params
header	umalloc.c	/^union header {$/;"	u	file:
height	.asm	/^	height = bitInfoHead.biHeight;$/;"	d
height	bitmap.h	/^	int height;$/;"	m	struct:PicNode
height	clickable.h	/^	int height;$/;"	m	struct:Rect
height	context.h	/^	int height;$/;"	m	struct:Context
hget1bit	common.c	/^unsigned int hget1bit()$/;"	f
hgetbits	common.c	/^unsigned long hgetbits(int N)$/;"	f
history	console.c	/^} history;$/;"	v	typeref:struct:__anon10
historyno	console.c	/^int historyno = -1;$/;"	v
hlen	huffman.h	/^  unsigned char *hlen;	\/*ָ array[xlen][ylen]ָ		*\/$/;"	m	struct:huffcodetab
holding	spinlock.c	/^holding(struct spinlock *lock)$/;"	f
hour	date.h	/^	uint hour;$/;"	m	struct:rtcdate
hp	.asm	/^  hp = (Header*)p;$/;"	d
hp	cat.asm	/^  hp = (Header*)p;$/;"	d
hp	decode.asm	/^  hp = (Header*)p;$/;"	d
hp	echo.asm	/^  hp = (Header*)p;$/;"	d
hp	grep.asm	/^  hp = (Header*)p;$/;"	d
hp	init.asm	/^  hp = (Header*)p;$/;"	d
hp	kill.asm	/^  hp = (Header*)p;$/;"	d
hp	ln.asm	/^  hp = (Header*)p;$/;"	d
hp	ls.asm	/^  hp = (Header*)p;$/;"	d
hp	mkdir.asm	/^  hp = (Header*)p;$/;"	d
hp	pause.asm	/^  hp = (Header*)p;$/;"	d
hp	play.asm	/^  hp = (Header*)p;$/;"	d
hputbuf	common.c	/^void hputbuf(unsigned int val, int N)$/;"	f
hsstell	common.c	/^unsigned long hsstell()$/;"	f
ht	huffman.c	/^struct huffcodetab ht[HTN];	\/*  huffcodtable headers	*\/$/;"	v	typeref:struct:huffcodetab
huffcodetab	huffman.h	/^struct huffcodetab {$/;"	s
huffman_decoder	huffman.c	/^int huffman_decoder(struct huffcodetab *h, int *x, int *y, int *v, int *w)$/;"	f
huffman_initialized	decodemp3.c	/^int huffman_initialized = FALSE;$/;"	v
hzk16Base	.asm	/^		hzk16Base = fontFile.buf;$/;"	d
i	.asm	/^  i = 0;$/;"	d
i	cat.asm	/^  i = 0;$/;"	d
i	decode.asm	/^  i = 0;$/;"	d
i	echo.asm	/^  i = 0;$/;"	d
i	grep.asm	/^  i = 0;$/;"	d
i	init.asm	/^  i = 0;$/;"	d
i	kill.asm	/^  i = 0;$/;"	d
i	ln.asm	/^  i = 0;$/;"	d
i	ls.asm	/^  i = 0;$/;"	d
i	mkdir.asm	/^  i = 0;$/;"	d
i	pause.asm	/^  i = 0;$/;"	d
i	play.asm	/^    i = 0;$/;"	d
i	play.asm	/^  i = 0;$/;"	d
i2b	mkfs.c	/^i2b(uint inum)$/;"	f
ialloc	fs.c	/^ialloc(uint dev, short type)$/;"	f
ialloc	mkfs.c	/^ialloc(ushort type)$/;"	f
iappend	mkfs.c	/^iappend(uint inum, void *xp, int n)$/;"	f
icache	fs.c	/^} icache;$/;"	v	typeref:struct:__anon16
iconlist	desktop.c	/^ICON iconlist[] = {$/;"	v
id	proc.h	/^  uchar id;                    \/\/ Local APIC ID; index into cpus[] below$/;"	m	struct:cpu
id	sound.h	/^  uint id;$/;"	m	struct:fmt
ideinit	ide.c	/^ideinit(void)$/;"	f
ideinit	memide.c	/^ideinit(void)$/;"	f
ideintr	ide.c	/^ideintr(void)$/;"	f
ideintr	memide.c	/^ideintr(void)$/;"	f
idelock	ide.c	/^static struct spinlock idelock;$/;"	v	typeref:struct:spinlock	file:
idequeue	ide.c	/^static struct buf *idequeue;$/;"	v	typeref:struct:buf	file:
iderw	ide.c	/^iderw(struct buf *b)$/;"	f
iderw	memide.c	/^iderw(struct buf *b)$/;"	f
idestart	ide.c	/^idestart(struct buf *b)$/;"	f	file:
idewait	ide.c	/^idewait(int checkerr)$/;"	f	file:
idt	trap.c	/^struct gatedesc idt[256];$/;"	v	typeref:struct:gatedesc
idtinit	trap.c	/^idtinit(void)$/;"	f
idup	fs.c	/^idup(struct inode *ip)$/;"	f
iget	fs.c	/^iget(uint dev, uint inum)$/;"	f	file:
iinit	fs.c	/^iinit(void)$/;"	f
ilock	fs.c	/^ilock(struct inode *ip)$/;"	f
imcrp	mp.h	/^  uchar imcrp;$/;"	m	struct:mp
inClientRect	window.c	/^int inClientRect(WindowLink pWindow, int position_x, int position_y)$/;"	f
inb	x86.h	/^inb(ushort port)$/;"	f
indent	.asm	/^			indent = 0;$/;"	d
indent	.asm	/^		indent = ((ICON_ITEM_WIDTH \/ 8) - strlen(name)) * 4;$/;"	d
index	.asm	/^		index = 0;$/;"	d
info	sound.h	/^  struct fmt info;$/;"	m	struct:wav	typeref:struct:wav::fmt
init	initcode.S	/^init:$/;"	l
initClickManager	clickable.c	/^ClickableManager initClickManager(struct Context c)$/;"	f
initPoint	clickable.c	/^Point initPoint(int x, int y)$/;"	f
initRect	clickable.c	/^Rect initRect(int x, int y, int w, int h)$/;"	f
init_context	context.c	/^int init_context(struct Context* context_ptr, int width, int height)$/;"	f
initializeASCII	drawingAPI.c	/^void initializeASCII()$/;"	f
initializeGBK	drawingAPI.c	/^void initializeGBK(){$/;"	f
initialize_huffman	decodemp3.c	/^void initialize_huffman()$/;"	f
initlock	spinlock.c	/^initlock(struct spinlock *lk, char *name)$/;"	f
initlog	log.c	/^initlog(void)$/;"	f
initproc	proc.c	/^static struct proc *initproc;$/;"	v	typeref:struct:proc	file:
inituvm	vm.c	/^inituvm(pde_t *pgdir, char *init, uint sz)$/;"	f
ino	stat.h	/^  uint ino;    \/\/ Inode number$/;"	m	struct:stat
inode	file.h	/^struct inode {$/;"	s
inode	fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon16	typeref:struct:__anon16::inode	file:
input	console.c	/^} input;$/;"	v	typeref:struct:__anon9
insl	x86.h	/^insl(int port, void *addr, int cnt)$/;"	f
install_trans	log.c	/^install_trans(void)$/;"	f	file:
int	.asm	/^int _RGB16BIT565(int r,int g,int b){$/;"	l
int	.asm	/^int executeHandler(Clickable *head, Point click)$/;"	l
int	.asm	/^int init_context(struct Context* context_ptr, int width, int height)$/;"	l
int	.asm	/^int isIn(Point p, Rect r)$/;"	l
int	.asm	/^int isListable(char *name, short type) {$/;"	l
int	.asm	/^int main(int argc, char *argv[]) {$/;"	l
int	.asm	/^int$/;"	l
int	cat.asm	/^int$/;"	l
int	decode.asm	/^int main()$/;"	l
int	decode.asm	/^int$/;"	l
int	echo.asm	/^int$/;"	l
int	forktest.asm	/^int$/;"	l
int	grep.asm	/^int match(char*, char*);$/;"	l
int	grep.asm	/^int matchhere(char *re, char *text)$/;"	l
int	grep.asm	/^int matchhere(char*, char*);$/;"	l
int	grep.asm	/^int matchstar(int c, char *re, char *text)$/;"	l
int	grep.asm	/^int matchstar(int, char*, char*);$/;"	l
int	grep.asm	/^int$/;"	l
int	init.asm	/^int$/;"	l
int	kill.asm	/^int$/;"	l
int	ln.asm	/^int$/;"	l
int	ls.asm	/^int$/;"	l
int	mkdir.asm	/^int$/;"	l
int	pause.asm	/^int main()$/;"	l
int	pause.asm	/^int$/;"	l
int	play.asm	/^int$/;"	l
int2str	finder.c	/^char * int2str(int i)$/;"	f
int_to_chars	cal.c	/^char* int_to_chars(char* ret, const int n){$/;"	f
intena	proc.h	/^  int intena;                  \/\/ Were interrupts enabled before pushcli?$/;"	m	struct:cpu
inum	file.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode
inum	fs.h	/^  ushort inum;$/;"	m	struct:dirent
inv_mdct	decodemp3.c	/^void inv_mdct(double in[18], double out[36], int block_type)$/;"	f
inw	x86.h	/^inw(ushort port)$/;"	f
ioapic	ioapic.c	/^struct ioapic {$/;"	s	file:
ioapic	ioapic.c	/^volatile struct ioapic *ioapic;$/;"	v	typeref:struct:ioapic
ioapicenable	ioapic.c	/^ioapicenable(int irq, int cpunum)$/;"	f
ioapicid	mp.c	/^uchar ioapicid;$/;"	v
ioapicinit	ioapic.c	/^ioapicinit(void)$/;"	f
ioapicread	ioapic.c	/^ioapicread(int reg)$/;"	f	file:
ioapicwrite	ioapic.c	/^ioapicwrite(int reg, uint data)$/;"	f	file:
iomb	mmu.h	/^  ushort iomb;       \/\/ I\/O map base address$/;"	m	struct:taskstate
ip	file.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode
iput	fs.c	/^iput(struct inode *ip)$/;"	f
iputtest	usertests.c	/^iputtest(void)$/;"	f
iref	usertests.c	/^iref(void)$/;"	f
irqmask	picirq.c	/^static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);$/;"	v	file:
isIn	clickable.c	/^int isIn(Point p, Rect r)$/;"	f
isListable	finder.c	/^int isListable(char *name, short type) {$/;"	f
isRun	.asm	/^	isRun = 0;$/;"	d
isRun	finder.c	/^int isRun = 1;$/;"	v
is_dragging	mouse.c	/^static int is_dragging = 0;$/;"	v	file:
isdecoding	sysaudio.c	/^int isdecoding = 0;$/;"	v
isdirempty	sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	file:
iskbdtype	console.c	/^int iskbdtype = 0;$/;"	v
ismp	mp.c	/^int ismp;$/;"	v
ismp3decoding	sysaudio.c	/^int ismp3decoding = 0;$/;"	v
ispaused	sysaudio.c	/^int ispaused = 0;$/;"	v
itemCounter	.asm	/^	itemCounter = 0;$/;"	d
itemCounter	finder.c	/^int itemCounter = 0; \/\/ 第几个文件$/;"	v
itrunc	fs.c	/^itrunc(struct inode *ip)$/;"	f	file:
iunlock	fs.c	/^iunlock(struct inode *ip)$/;"	f
iunlockput	fs.c	/^iunlockput(struct inode *ip)$/;"	f
iupdate	fs.c	/^iupdate(struct inode *ip)$/;"	f
js_bound	common.c	/^int js_bound(int lay, int m_ext)$/;"	f
jsbound	common.h	/^    int         jsbound;        \/* ĵһ *\/$/;"	m	struct:frame_params
k	.asm	/^				k = i*l_width + j*3;$/;"	d
kalloc	kalloc.c	/^kalloc(void)$/;"	f
kbdintr	kbd.c	/^kbdintr(void)$/;"	f
key	message.h	/^	char key;$/;"	m	struct:MsgKey
kfree	kalloc.c	/^kfree(char *v)$/;"	f
kill	proc.c	/^kill(int pid)$/;"	f
killed	proc.h	/^  int killed;                  \/\/ If non-zero, have been killed$/;"	m	struct:proc
kinit1	kalloc.c	/^kinit1(void *vstart, void *vend)$/;"	f
kinit2	kalloc.c	/^kinit2(void *vstart, void *vend)$/;"	f
kmap	vm.c	/^static struct kmap {$/;"	s	file:
kmap	vm.c	/^} kmap[] = {$/;"	v	typeref:struct:kmap	file:
kmem	kalloc.c	/^} kmem;$/;"	v	typeref:struct:__anon8
kpgdir	vm.c	/^pde_t *kpgdir;  \/\/ for use in scheduler()$/;"	v
kstack	proc.h	/^  char *kstack;                \/\/ Bottom of kernel stack for this process$/;"	m	struct:proc
kvmalloc	vm.c	/^kvmalloc(void)$/;"	f
l	common.h	/^	int l[23];			\/* [cb] *\/$/;"	m	struct:__anon15
l	decodemp3.c	/^	int l[23];$/;"	m	struct:__anon4	file:
l	decodemp3.c	/^	int l[5];$/;"	m	struct:__anon3	file:
lapic	lapic.c	/^volatile uint *lapic;  \/\/ Initialized in mp.c$/;"	v
lapicaddr	mp.h	/^  uint *lapicaddr;              \/\/ address of local APIC$/;"	m	struct:mpconf
lapiceoi	lapic.c	/^lapiceoi(void)$/;"	f
lapicinit	lapic.c	/^lapicinit(void)$/;"	f
lapicstartap	lapic.c	/^lapicstartap(uchar apicid, uint addr)$/;"	f
lapicw	lapic.c	/^lapicw(int index, int value)$/;"	f	file:
lay	common.h	/^    int lay;$/;"	m	struct:__anon13
layer	common.h	/^} layer, *the_layer;$/;"	t	typeref:struct:__anon13
layer_names	common.c	/^char *layer_names[3] = { "I", "II", "III" };$/;"	v
lcr3	x86.h	/^lcr3(uint val) $/;"	f
ldt	mmu.h	/^  ushort ldt;$/;"	m	struct:taskstate
left	sh.c	/^  struct cmd *left;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
left	sh.c	/^  struct cmd *left;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
left_already_down	mouse.c	/^static int left_already_down = 0;$/;"	v	file:
left_click	clickable.h	/^	Clickable *left_click;$/;"	m	struct:ClickableManager
left_click_tick	mouse.c	/^static int left_click_tick = -20;$/;"	v	file:
left_down	mouse.c	/^static int left_down = 0;$/;"	v	file:
left_x	window.h	/^	int left_x;$/;"	m	struct:Rect
left_y	window.h	/^	int left_y;$/;"	m	struct:Rect
len	.asm	/^		len = dx + 1;$/;"	d
len	.asm	/^		len = dy + 1;$/;"	d
len	sound.h	/^  uint len;$/;"	m	struct:fmt
length	mp.h	/^  uchar length;                 \/\/ 1$/;"	m	struct:mp
length	mp.h	/^  ushort length;                \/\/ total table length$/;"	m	struct:mpconf
lgdt	x86.h	/^lgdt(struct segdesc *p, int size)$/;"	f
lh	log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:
lidt	x86.h	/^lidt(struct gatedesc *p, int size)$/;"	f
lim_15_0	mmu.h	/^  uint lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segdesc
lim_19_16	mmu.h	/^  uint lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segdesc
linbits	huffman.h	/^  unsigned int linbits; \/* linbits	Ŀ 		*\/$/;"	m	struct:huffcodetab
link	mmu.h	/^  uint link;         \/\/ Old ts selector$/;"	m	struct:taskstate
linktest	usertests.c	/^linktest(void)$/;"	f
linkunlink	usertests.c	/^linkunlink()$/;"	f
linmax	huffman.h	/^  unsigned int linmax;	\/*洢linbitsеĿ 	*\/$/;"	m	struct:huffcodetab
list	finder.c	/^void list(char *path) {$/;"	f
list_head	window.c	/^WindowLink list_head = 0;$/;"	v
list_tail	window.c	/^WindowLink list_tail = 0;$/;"	v
listcmd	sh.c	/^listcmd(struct cmd *left, struct cmd *right)$/;"	f
listcmd	sh.c	/^struct listcmd {$/;"	s	file:
ln	math.c	/^double ln(double x)$/;"	f
loadBitmap	bitmap.c	/^void loadBitmap(PICNODE *pic, char pic_name[])$/;"	f
load_iconlist	drawingAPI.c	/^void load_iconlist(ICON* iconlist, int len)$/;"	f
loadgs	x86.h	/^loadgs(ushort v)$/;"	f
loaduvm	vm.c	/^loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)$/;"	f
lock	bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon2	typeref:struct:__anon2::spinlock	file:
lock	console.c	/^	struct spinlock lock;$/;"	m	struct:__anon9	typeref:struct:__anon9::spinlock	file:
lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon11	typeref:struct:__anon11::spinlock	file:
lock	file.c	/^  struct spinlock lock;$/;"	m	struct:__anon5	typeref:struct:__anon5::spinlock	file:
lock	fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon16	typeref:struct:__anon16::spinlock	file:
lock	kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon8	typeref:struct:__anon8::spinlock	file:
lock	log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:
lock	pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:
lock	proc.c	/^  struct spinlock lock;$/;"	m	struct:__anon1	typeref:struct:__anon1::spinlock	file:
lock	sysaudio.c	/^    struct spinlock lock;$/;"	m	struct:decode	typeref:struct:decode::spinlock	file:
lock	sysaudio.c	/^    struct spinlock lock;$/;"	m	struct:snd	typeref:struct:snd::spinlock	file:
locked	spinlock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock
locking	console.c	/^  int locking;$/;"	m	struct:__anon11	file:
log	log.c	/^struct log log;$/;"	v	typeref:struct:log
log	log.c	/^struct log {$/;"	s	file:
log_write	log.c	/^log_write(struct buf *b)$/;"	f
logheader	log.c	/^struct logheader {$/;"	s	file:
ls	cp.c	/^void ls(char *path)$/;"	f
ls	ls.c	/^ls(char *path)$/;"	f
ls	mv.c	/^void ls(char *path)$/;"	f
ltr	x86.h	/^ltr(ushort sel)$/;"	f
m	grep.asm	/^      m = 0;$/;"	d
m	grep.asm	/^  m = 0;$/;"	d
machine	elf.h	/^  ushort machine;$/;"	m	struct:elfhdr
magic	elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr
main	cal.c	/^main(int argc, char *argv[])$/;"	f
main	cat.c	/^main(int argc, char *argv[])$/;"	f
main	cp.c	/^int main(int argc, char *argv[])$/;"	f
main	decode.c	/^int main()$/;"	f
main	desktop.c	/^int main(int argc, char *argv[])$/;"	f
main	echo.c	/^main(int argc, char *argv[])$/;"	f
main	editor.c	/^int main(int argc, char *argv[])$/;"	f
main	finder.c	/^int main(int argc, char *argv[]) {$/;"	f
main	forktest.c	/^main(void)$/;"	f
main	grep.c	/^main(int argc, char *argv[])$/;"	f
main	init.c	/^main(void)$/;"	f
main	kill.c	/^main(int argc, char **argv)$/;"	f
main	layer3.c	/^void main(int argc, char**argv)$/;"	f
main	ln.c	/^main(int argc, char *argv[])$/;"	f
main	ls.c	/^main(int argc, char *argv[])$/;"	f
main	main.c	/^main(void)$/;"	f
main	mkdir.c	/^main(int argc, char *argv[])$/;"	f
main	mkfs.c	/^main(int argc, char *argv[])$/;"	f
main	mp3dec.c	/^int main()$/;"	f
main	mv.c	/^int main(int argc, char *argv[])$/;"	f
main	pause.c	/^int main()$/;"	f
main	play.c	/^main(int argc, char *argv[])$/;"	f
main	playmp3.c	/^int main(int argc, char**argv)$/;"	f
main	ren.c	/^main(int argc, char *argv[])$/;"	f
main	rm.c	/^main(int argc, char *argv[])$/;"	f
main	sh.c	/^main(void)$/;"	f
main	shell.c	/^main(int argc, char *argv[])$/;"	f
main	splice.c	/^main(int argc, char *argv[])$/;"	f
main	stressfs.c	/^main(int argc, char *argv[])$/;"	f
main	touch.c	/^main(int argc, char *argv[])$/;"	f
main	uptime.c	/^int main()$/;"	f
main	usertests.c	/^main(int argc, char *argv[])$/;"	f
main	wc.c	/^main(int argc, char *argv[])$/;"	f
main	zombie.c	/^main(void)$/;"	f
main_data_begin	common.h	/^	unsigned main_data_begin;$/;"	m	struct:III_side_info_t
main_data_slots	decodemp3.c	/^int main_data_slots(struct frame_params fr_ps)$/;"	f
major	file.h	/^  short major;$/;"	m	struct:inode
major	fs.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode
malloc	umalloc.c	/^malloc(uint nbytes)$/;"	f
mappages	vm.c	/^mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)$/;"	f	file:
mask	common.c	/^int mask[8]={0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};$/;"	v
match	grep.c	/^match(char *re, char *text)$/;"	f
matchcmd	console.c	/^char matchcmd[COMMANDNUM][COMMANDMAXLENDTH];$/;"	v
matchcmdno	console.c	/^int matchcmdno;$/;"	v
matchcmdnum	console.c	/^int matchcmdnum;$/;"	v
matchhere	grep.c	/^int matchhere(char *re, char *text)$/;"	f
matchinput	console.c	/^char matchinput[COMMANDMAXLENDTH];$/;"	v
matchinputlen	console.c	/^int matchinputlen = 0;$/;"	v
matchstar	grep.c	/^int matchstar(int c, char *re, char *text)$/;"	f
mem	usertests.c	/^mem(void)$/;"	f
mem_alloc	common.c	/^void *mem_alloc(unsigned long block, char *item)$/;"	f
memcmp	string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f
memcpy	string.c	/^memcpy(void *dst, const void *src, uint n)$/;"	f
memdisk	memide.c	/^static uchar *memdisk;$/;"	v	file:
memmove	string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f
memmove	ulib.c	/^memmove(void *vdst, void *vsrc, int n)$/;"	f
memset	string.c	/^memset(void *dst, int c, uint n)$/;"	f
memset	ulib.c	/^memset(void *dst, int c, uint n)$/;"	f
memsz	elf.h	/^  uint memsz;$/;"	m	struct:proghdr
microdelay	lapic.c	/^microdelay(int us)$/;"	f
min	fs.c	23;"	d	file:
min	mkfs.c	257;"	d	file:
minor	file.h	/^  short minor;$/;"	m	struct:inode
minor	fs.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode
minute	date.h	/^	uint minute;$/;"	m	struct:rtcdate
mixed_block_flag	common.h	/^			unsigned mixed_block_flag;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
mode	common.h	/^    int         mode;           \/* ģʽ\/д*\/$/;"	m	struct:bit_stream_struc
mode	common.h	/^    int mode;$/;"	m	struct:__anon13
mode	sh.c	/^  int mode;$/;"	m	struct:redircmd	file:
mode_ext	common.h	/^    int mode_ext;$/;"	m	struct:__anon13
mode_names	common.c	/^char *mode_names[4] = { "stereo", "j-stereo", "dual-ch", "single-ch" };$/;"	v
month	date.h	/^	uint month;$/;"	m	struct:rtcdate
morecore	umalloc.c	/^morecore(uint nu)$/;"	f	file:
mouse	window.c	/^static color16 mouse[10][15] = {$/;"	v	file:
mouseX	window.c	/^static int mouseX = -1;$/;"	v	file:
mouseY	window.c	/^static int mouseY = -1;$/;"	v	file:
mouse_lock	mouse.c	/^static struct spinlock mouse_lock;$/;"	v	typeref:struct:spinlock	file:
mouse_x	message.c	/^int mouse_x;$/;"	v
mouse_y	message.c	/^int mouse_y;$/;"	v
mouseinit	mouse.c	/^mouseinit()$/;"	f
mouseintr	mouse.c	/^mouseintr(uint tick)$/;"	f
mp	mp.h	/^struct mp {             \/\/ floating pointer$/;"	s
mp3lock	sysaudio.c	/^struct decode decodelock, mp3lock;$/;"	v	typeref:struct:
mpbcpu	mp.c	/^mpbcpu(void)$/;"	f
mpconf	mp.h	/^struct mpconf {         \/\/ configuration table header$/;"	s
mpconfig	mp.c	/^mpconfig(struct mp **pmp)$/;"	f	file:
mpenter	main.c	/^mpenter(void)$/;"	f	file:
mpinit	mp.c	/^mpinit(void)$/;"	f
mpioapic	mp.h	/^struct mpioapic {       \/\/ I\/O APIC table entry$/;"	s
mpmain	main.c	/^mpmain(void)$/;"	f	file:
mpproc	mp.h	/^struct mpproc {         \/\/ processor table entry$/;"	s
mpsearch	mp.c	/^mpsearch(void)$/;"	f	file:
mpsearch1	mp.c	/^mpsearch1(uint a, int len)$/;"	f	file:
msg_key	message.h	/^		struct MsgKey msg_key;$/;"	m	union:Msg::__anon7	typeref:struct:Msg::__anon7::MsgKey
msg_mouse	message.h	/^		struct MsgMouse msg_mouse;$/;"	m	union:Msg::__anon7	typeref:struct:Msg::__anon7::MsgMouse
msg_partial_update	message.h	/^        struct MsgPartialUpdate msg_partial_update;$/;"	m	union:Msg::__anon7	typeref:struct:Msg::__anon7::MsgPartialUpdate
msg_type	message.h	/^	int msg_type;$/;"	m	struct:Msg
msgqueueinit	message.c	/^void msgqueueinit()$/;"	f
msgtableinit	message.c	/^void msgtableinit()$/;"	f
multiboot_header	entry.S	/^multiboot_header:$/;"	l
n	.asm	/^		n = strlen(name);$/;"	d
n	.asm	/^	n = read(fd, BmpFileHeader, 14);$/;"	d
n	.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	.asm	/^  n = 0;$/;"	d
n	cat.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	cat.asm	/^  n = 0;$/;"	d
n	decode.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	decode.asm	/^  n = 0;$/;"	d
n	echo.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	echo.asm	/^  n = 0;$/;"	d
n	forktest.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	forktest.asm	/^  n = 0;$/;"	d
n	grep.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	grep.asm	/^  n = 0;$/;"	d
n	init.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	init.asm	/^  n = 0;$/;"	d
n	kill.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	kill.asm	/^  n = 0;$/;"	d
n	ln.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ln.asm	/^  n = 0;$/;"	d
n	log.c	/^  int n;   $/;"	m	struct:logheader	file:
n	ls.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ls.asm	/^  n = 0;$/;"	d
n	mkdir.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	mkdir.asm	/^  n = 0;$/;"	d
n	pause.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	pause.asm	/^  n = 0;$/;"	d
n	play.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	play.asm	/^  n = 0;$/;"	d
name	.asm	/^  name: \\$/;"	l
name	cat.asm	/^  name: \\$/;"	l
name	decode.asm	/^  name: \\$/;"	l
name	drawingAPI.h	/^    char name[32];$/;"	m	struct:Icon
name	echo.asm	/^  name: \\$/;"	l
name	finder.c	/^	char *name;$/;"	m	struct:fileItem	file:
name	forktest.asm	/^  name: \\$/;"	l
name	fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent
name	grep.asm	/^  name: \\$/;"	l
name	init.asm	/^  name: \\$/;"	l
name	kill.asm	/^  name: \\$/;"	l
name	ln.asm	/^  name: \\$/;"	l
name	ls.asm	/^  name: \\$/;"	l
name	mkdir.asm	/^  name: \\$/;"	l
name	pause.asm	/^  name: \\$/;"	l
name	play.asm	/^  name: \\$/;"	l
name	proc.h	/^  char name[16];               \/\/ Process name (debugging)$/;"	m	struct:proc
name	spinlock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:spinlock
name	usertests.c	/^char name[3];$/;"	v
name	usys.S	/^  name: \\$/;"	l
nameColor	.asm	/^		nameColor = 0x0;$/;"	d
nameColor	.asm	/^		nameColor = 0xFFFF;$/;"	d
namecmp	fs.c	/^namecmp(const char *s, const char *t)$/;"	f
namei	fs.c	/^namei(char *path)$/;"	f
nameiparent	fs.c	/^nameiparent(char *path, char *name)$/;"	f
namex	fs.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	file:
nblocks	fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock
nblocks	mkfs.c	/^int nblocks = 1024 * 1024 - 3 - 256 - 26 - LOGSIZE;$/;"	v
ncli	proc.h	/^  int ncli;                    \/\/ Depth of pushcli nesting.$/;"	m	struct:cpu
ncpu	mp.c	/^int ncpu;$/;"	v
neg	.asm	/^    neg = 1;$/;"	d
neg	.asm	/^  neg = 0;$/;"	d
neg	cat.asm	/^    neg = 1;$/;"	d
neg	cat.asm	/^  neg = 0;$/;"	d
neg	decode.asm	/^    neg = 1;$/;"	d
neg	decode.asm	/^  neg = 0;$/;"	d
neg	echo.asm	/^    neg = 1;$/;"	d
neg	echo.asm	/^  neg = 0;$/;"	d
neg	grep.asm	/^    neg = 1;$/;"	d
neg	grep.asm	/^  neg = 0;$/;"	d
neg	init.asm	/^    neg = 1;$/;"	d
neg	init.asm	/^  neg = 0;$/;"	d
neg	kill.asm	/^    neg = 1;$/;"	d
neg	kill.asm	/^  neg = 0;$/;"	d
neg	ln.asm	/^    neg = 1;$/;"	d
neg	ln.asm	/^  neg = 0;$/;"	d
neg	ls.asm	/^    neg = 1;$/;"	d
neg	ls.asm	/^  neg = 0;$/;"	d
neg	mkdir.asm	/^    neg = 1;$/;"	d
neg	mkdir.asm	/^  neg = 0;$/;"	d
neg	pause.asm	/^    neg = 1;$/;"	d
neg	pause.asm	/^  neg = 0;$/;"	d
neg	play.asm	/^    neg = 1;$/;"	d
neg	play.asm	/^  neg = 0;$/;"	d
newFile	finder.c	/^void newFile(char *name) {$/;"	f
newFolder	finder.c	/^void newFolder(char *name) {$/;"	f
next	buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf::buf
next	clickable.h	/^	struct Clickable *next;$/;"	m	struct:Clickable	typeref:struct:Clickable::Clickable
next	finder.c	/^	struct fileItem *next;$/;"	m	struct:fileItem	typeref:struct:fileItem::fileItem	file:
next	kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:
next	sound.h	/^  struct soundNode *next;$/;"	m	struct:soundNode	typeref:struct:soundNode::soundNode
next_msg	message.h	/^	int next_msg;\/\/下一个消息在全局消息队列中的索引$/;"	m	struct:Msg
next_window	window.h	/^	struct Window *next_window;$/;"	m	struct:Window	typeref:struct:Window::Window
next_window_id	window.c	/^int next_window_id = 1;$/;"	v
nextpid	proc.c	/^int nextpid = 1;$/;"	v
ninodes	fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock
ninodes	mkfs.c	/^int ninodes = 200;$/;"	v
nlink	file.h	/^  short nlink;$/;"	m	struct:inode
nlink	fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode
nlink	stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat
nlog	fs.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock
nlog	mkfs.c	/^int nlog = LOGSIZE;$/;"	v
normalmap	kbd.h	/^static uchar normalmap[256] =$/;"	v
nread	pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	file:
nread	sysaudio.c	/^    uint nread;$/;"	m	struct:decode	file:
nu	.asm	/^    nu = 4096;$/;"	d
nu	cat.asm	/^    nu = 4096;$/;"	d
nu	decode.asm	/^    nu = 4096;$/;"	d
nu	echo.asm	/^    nu = 4096;$/;"	d
nu	grep.asm	/^    nu = 4096;$/;"	d
nu	init.asm	/^    nu = 4096;$/;"	d
nu	kill.asm	/^    nu = 4096;$/;"	d
nu	ln.asm	/^    nu = 4096;$/;"	d
nu	ls.asm	/^    nu = 4096;$/;"	d
nu	mkdir.asm	/^    nu = 4096;$/;"	d
nu	pause.asm	/^    nu = 4096;$/;"	d
nu	play.asm	/^    nu = 4096;$/;"	d
nulterminate	sh.c	/^nulterminate(struct cmd *cmd)$/;"	f
nunits	.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	cat.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	decode.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	echo.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	grep.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	init.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	kill.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ln.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ls.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	mkdir.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	pause.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	play.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nwrite	pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	file:
nwrite	sysaudio.c	/^    uint nwrite;$/;"	m	struct:decode	file:
oemlength	mp.h	/^  ushort oemlength;             \/\/ OEM table length$/;"	m	struct:mpconf
oemtable	mp.h	/^  uint *oemtable;               \/\/ OEM table pointer$/;"	m	struct:mpconf
oesp	x86.h	/^  uint oesp;      \/\/ useless & ignored$/;"	m	struct:trapframe
off	elf.h	/^  uint off;$/;"	m	struct:proghdr
off	file.h	/^  uint off;$/;"	m	struct:file
off_15_0	mmu.h	/^  uint off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedesc
off_31_16	mmu.h	/^  uint off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedesc
offset	.asm	/^		offset = (((gbk & 0x00FF) - 0xa1) * 94 + (((gbk >> 8) & 0x00FF) - 0xa1)) * 32;$/;"	d
offset	sound.h	/^	unsigned long offset, totbit, buf_byte_idx;$/;"	m	struct:coreBuf
ofile	proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:proc::file
open_bit_stream_r	common.c	/^void open_bit_stream_r(Bit_stream_struc *bs, char *bs_filenam, int size)$/;"	f
openiputtest	usertests.c	/^openiputtest(void)$/;"	f
opentest	usertests.c	/^opentest(void)$/;"	f
original	common.h	/^    int original;$/;"	m	struct:__anon13
os	.asm	/^  os = s;$/;"	d
os	cat.asm	/^  os = s;$/;"	d
os	decode.asm	/^  os = s;$/;"	d
os	echo.asm	/^  os = s;$/;"	d
os	forktest.asm	/^  os = s;$/;"	d
os	grep.asm	/^  os = s;$/;"	d
os	init.asm	/^  os = s;$/;"	d
os	kill.asm	/^  os = s;$/;"	d
os	ln.asm	/^  os = s;$/;"	d
os	ls.asm	/^  os = s;$/;"	d
os	mkdir.asm	/^  os = s;$/;"	d
os	pause.asm	/^  os = s;$/;"	d
os	play.asm	/^  os = s;$/;"	d
out_fifo	decodemp3.c	/^void out_fifo(short pcm_sample[2][SSLIMIT][SBLIMIT], int num, struct frame_params *fr_ps, unsigned long *psampFrames)$/;"	f
outb	x86.h	/^outb(ushort port, uchar data)$/;"	f
outsl	x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f
outstanding	log.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:
outw	x86.h	/^outw(ushort port, ushort data)$/;"	f
p	.asm	/^			p = initPoint(i,j);$/;"	d
p	.asm	/^			p = initPoint(msg.concrete_msg.msg_mouse.x,$/;"	d
p	.asm	/^		p = buf + strlen(buf);$/;"	d
p	.asm	/^		p = p->next;$/;"	d
p	.asm	/^	p = fileItemList;$/;"	d
p	.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	cat.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	decode.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	echo.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	grep.asm	/^      p = q+1;$/;"	d
p	grep.asm	/^    p = buf;$/;"	d
p	grep.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	init.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	kill.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	ln.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	ls.asm	/^    p = buf+strlen(buf);$/;"	d
p	ls.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	mkdir.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	mmu.h	/^  uint p : 1;           \/\/ Present$/;"	m	struct:gatedesc
p	mmu.h	/^  uint p : 1;          \/\/ Present$/;"	m	struct:segdesc
p	pause.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	play.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p2v	memlayout.h	/^static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }$/;"	f
pad	ioapic.c	/^  uint pad[3];$/;"	m	struct:ioapic	file:
pad	runoff	/^pad()$/;"	f
pad	sound.h	/^  ushort pad;$/;"	m	struct:fmt
padding	common.h	/^    int padding;$/;"	m	struct:__anon13
padding1	mmu.h	/^  ushort padding1;$/;"	m	struct:taskstate
padding1	x86.h	/^  ushort padding1;$/;"	m	struct:trapframe
padding10	mmu.h	/^  ushort padding10;$/;"	m	struct:taskstate
padding2	mmu.h	/^  ushort padding2;$/;"	m	struct:taskstate
padding2	x86.h	/^  ushort padding2;$/;"	m	struct:trapframe
padding3	mmu.h	/^  ushort padding3;$/;"	m	struct:taskstate
padding3	x86.h	/^  ushort padding3;$/;"	m	struct:trapframe
padding4	mmu.h	/^  ushort padding4;$/;"	m	struct:taskstate
padding4	x86.h	/^  ushort padding4;$/;"	m	struct:trapframe
padding5	mmu.h	/^  ushort padding5;$/;"	m	struct:taskstate
padding5	x86.h	/^  ushort padding5;$/;"	m	struct:trapframe
padding6	mmu.h	/^  ushort padding6;$/;"	m	struct:taskstate
padding6	x86.h	/^  ushort padding6;$/;"	m	struct:trapframe
padding7	mmu.h	/^  ushort padding7;$/;"	m	struct:taskstate
padding8	mmu.h	/^  ushort padding8;$/;"	m	struct:taskstate
padding9	mmu.h	/^  ushort padding9;$/;"	m	struct:taskstate
paddr	elf.h	/^  uint paddr;$/;"	m	struct:proghdr
panic	console.c	/^panic(char *s)$/;"	f
panic	sh.c	/^panic(char *s)$/;"	f
panicked	console.c	/^static int panicked = 0;$/;"	v	file:
parent	proc.h	/^  struct proc *parent;         \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc::proc
parseblock	sh.c	/^parseblock(char **ps, char *es)$/;"	f
parsecmd	sh.c	/^parsecmd(char *s)$/;"	f
parseexec	sh.c	/^parseexec(char **ps, char *es)$/;"	f
parseline	sh.c	/^parseline(char **ps, char *es)$/;"	f
parsepipe	sh.c	/^parsepipe(char **ps, char *es)$/;"	f
parseredirs	sh.c	/^parseredirs(struct cmd *cmd, char **ps, char *es)$/;"	f
part2_3_length	common.h	/^			unsigned part2_3_length;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
pattern	grep.asm	/^  pattern = argv[1];$/;"	d
pcs	spinlock.h	/^  uint pcs[10];      \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock
pde_t	types.h	/^typedef uint pde_t;$/;"	t
peek	sh.c	/^peek(char **ps, char *es, char *toks)$/;"	f
perm	vm.c	/^  int perm;$/;"	m	struct:kmap	file:
pgdir	proc.h	/^  pde_t* pgdir;                \/\/ Page table$/;"	m	struct:proc
phentsize	elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr
phnum	elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr
phoff	elf.h	/^  uint phoff;$/;"	m	struct:elfhdr
phys_end	vm.c	/^  uint phys_end;$/;"	m	struct:kmap	file:
phys_start	vm.c	/^  uint phys_start;$/;"	m	struct:kmap	file:
physaddr	mp.h	/^  void *physaddr;               \/\/ phys addr of MP config table$/;"	m	struct:mp
pi	math.c	2;"	d	file:
pic	drawingAPI.h	/^    PICNODE pic;$/;"	m	struct:Icon
picenable	picirq.c	/^picenable(int irq)$/;"	f
picinit	picirq.c	/^picinit(void)$/;"	f
picsetmask	picirq.c	/^picsetmask(ushort mask)$/;"	f	file:
pid	forktest.asm	/^    pid = fork();$/;"	d
pid	init.asm	/^    pid = fork();$/;"	d
pid	message.h	/^	int pid;$/;"	m	struct:MsgTableEntry
pid	proc.h	/^  int pid;                     \/\/ Process ID$/;"	m	struct:proc
pid	window.h	/^	int pid;$/;"	m	struct:Window
pinit	proc.c	/^pinit(void)$/;"	f
pipe	file.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe
pipe	pipe.c	/^struct pipe {$/;"	s	file:
pipe1	usertests.c	/^pipe1(void)$/;"	f
pipealloc	pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f
pipeclose	pipe.c	/^pipeclose(struct pipe *p, int writable)$/;"	f
pipecmd	sh.c	/^pipecmd(struct cmd *left, struct cmd *right)$/;"	f
pipecmd	sh.c	/^struct pipecmd {$/;"	s	file:
piperead	pipe.c	/^piperead(struct pipe *p, char *addr, int n)$/;"	f
pipewrite	pipe.c	/^pipewrite(struct pipe *p, char *addr, int n)$/;"	f
playSound	sound.c	/^void playSound(void)$/;"	f
popcli	spinlock.c	/^popcli(void)$/;"	f
pos	finder.c	/^	Rect pos;$/;"	m	struct:fileItem	file:
position_x	drawingAPI.h	/^    int position_x;$/;"	m	struct:Icon
position_y	drawingAPI.h	/^    int position_y;$/;"	m	struct:Icon
posoffset	console.c	/^int posoffset = 0;$/;"	v
pow	math.c	/^double pow(double x, double y)$/;"	f
precede	cal.c	/^char precede(char x, char y){$/;"	f
preempt	usertests.c	/^preempt(void)$/;"	f
preflag	common.h	/^			unsigned preflag;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
pretab	decodemp3.c	/^int pretab[22] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0};$/;"	v
prev	.asm	/^				prev = prev->next;$/;"	d
prev	.asm	/^	prev = cur = *head;$/;"	d
prev	buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf::buf
printBinary	drawingAPI.c	/^void printBinary(char c)$/;"	f
printClickable	clickable.c	/^void printClickable(Clickable *c)$/;"	f
printClickableList	clickable.c	/^void printClickableList(Clickable *head)$/;"	f
printItemList	finder.c	/^void printItemList() {$/;"	f
printRect	window.c	/^void printRect(Rect rect)$/;"	f
printf	forktest.c	/^printf(int fd, char *s, ...)$/;"	f
printf	printf.c	/^printf(int fd, char *fmt, ...)$/;"	f
printint	console.c	/^printint(int xx, int base, int sign)$/;"	f	file:
printint	printf.c	/^printint(int fd, int xx, int base, int sgn)$/;"	f	file:
prior_window	window.h	/^	struct Window *prior_window;$/;"	m	struct:Window	typeref:struct:Window::Window
private_bits	common.h	/^	unsigned private_bits;$/;"	m	struct:III_side_info_t
proc	proc.c	/^  struct proc proc[NPROC];$/;"	m	struct:__anon1	typeref:struct:__anon1::proc	file:
proc	proc.h	/^  struct proc *proc;           \/\/ The currently-running process.$/;"	m	struct:cpu	typeref:struct:cpu::proc
proc	proc.h	/^struct proc {$/;"	s
procdump	proc.c	/^procdump(void)$/;"	f
procstate	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	g
product	mp.h	/^  uchar product[20];            \/\/ product id$/;"	m	struct:mpconf
proghdr	elf.h	/^struct proghdr {$/;"	s
pt	common.h	/^    int        pt;            \/* 豸ָ *\/$/;"	m	struct:bit_stream_struc
ptable	proc.c	/^} ptable;$/;"	v	typeref:struct:__anon1
pte_t	mmu.h	/^typedef uint pte_t;$/;"	t
ptr	umalloc.c	/^    union header *ptr;$/;"	m	struct:header::__anon6	typeref:union:header::__anon6::header	file:
pushcli	spinlock.c	/^pushcli(void)$/;"	f
put_ascii	drawingAPI.c	/^void put_ascii(struct Context c, unsigned char ascii, unsigned short colorNum, int x, int y)$/;"	f
put_gbk	drawingAPI.c	/^void put_gbk(struct Context c, short gbk, unsigned short colorNum, int x, int y)$/;"	f
putc	printf.c	/^putc(int fd, char c)$/;"	f	file:
putmask	common.c	/^int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};$/;"	v
putmask	sysaudio.c	/^int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};$/;"	v
puts_str	drawingAPI.c	/^void puts_str(struct Context c, char *str, unsigned short colorNum, int x, int y)$/;"	f
q	.asm	/^		q = q->next;$/;"	d
qnext	buf.h	/^  struct buf *qnext; \/\/ disk queue$/;"	m	struct:buf	typeref:struct:buf::buf
r	.asm	/^  r = fstat(fd, st);$/;"	d
r	cat.asm	/^  r = fstat(fd, st);$/;"	d
r	console.c	/^	uint r;  \/\/ Read index$/;"	m	struct:__anon9	file:
r	decode.asm	/^  r = fstat(fd, st);$/;"	d
r	echo.asm	/^  r = fstat(fd, st);$/;"	d
r	forktest.asm	/^  r = fstat(fd, st);$/;"	d
r	grep.asm	/^  r = fstat(fd, st);$/;"	d
r	init.asm	/^  r = fstat(fd, st);$/;"	d
r	kill.asm	/^  r = fstat(fd, st);$/;"	d
r	ln.asm	/^  r = fstat(fd, st);$/;"	d
r	ls.asm	/^  r = fstat(fd, st);$/;"	d
r	mkdir.asm	/^  r = fstat(fd, st);$/;"	d
r	pause.asm	/^  r = fstat(fd, st);$/;"	d
r	play.asm	/^  r = fstat(fd, st);$/;"	d
rand	usertests.c	/^rand()$/;"	f
randstate	usertests.c	/^unsigned long randstate = 1;$/;"	v
rcr2	x86.h	/^rcr2(void)$/;"	f
read	file.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw
read_decoder_table	huffman.c	/^void read_decoder_table() $/;"	f
read_head	log.c	/^read_head(void)$/;"	f	file:
read_pci_config	sound.c	/^uint read_pci_config(uchar bus, uchar slot, uchar func, uchar offset)$/;"	f
read_syn_window	decodemp3.c	/^void read_syn_window(double window[HAN_SIZE])$/;"	f
readable	file.h	/^  char readable;$/;"	m	struct:file
readeflags	x86.h	/^readeflags(void)$/;"	f
readi	fs.c	/^readi(struct inode *ip, char *dst, uint off, uint n)$/;"	f
readopen	pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:
readsb	fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f
readsect	bootmain.c	/^readsect(void *dst, uint offset)$/;"	f
readseg	bootmain.c	/^readseg(uchar* pa, uint count, uint offset)$/;"	f
recover_from_log	log.c	/^recover_from_log(void)$/;"	f	file:
redircmd	sh.c	/^redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)$/;"	f
redircmd	sh.c	/^struct redircmd {$/;"	s	file:
ref	file.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode
ref	file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file
ref	huffman.h	/^  int ref;		\/*a positive value indicates a reference*\/$/;"	m	struct:huffcodetab
refill_buffer	common.c	/^void refill_buffer(Bit_stream_struc *bs)$/;"	f
reg	ioapic.c	/^  uint reg;$/;"	m	struct:ioapic	file:
region0_count	common.h	/^			unsigned region0_count;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
region1_count	common.h	/^			unsigned region1_count;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
release	spinlock.c	/^release(struct spinlock *lk)$/;"	f
releaseWindow	window.c	/^int releaseWindow(int window_id)$/;"	f
requireMsg	message.c	/^int requireMsg(int msg_type, int pos_x, int pos_y, char key)$/;"	f
requirePartialUpdateMsg	message.c	/^int requirePartialUpdateMsg(int x1, int y1, int x2, int y2)$/;"	f
reserved	mp.h	/^  uchar reserved;$/;"	m	struct:mpconf
reserved	mp.h	/^  uchar reserved[3];$/;"	m	struct:mp
reserved	mp.h	/^  uchar reserved[8];$/;"	m	struct:mpproc
rewindNbits	common.c	/^void rewindNbits(int N)$/;"	f
rewindNbytes	common.c	/^void rewindNbytes(int N)$/;"	f
rgb	.asm	/^			rgb = pic.data[i*pic.width+j];$/;"	d
rgbBlue	bitmap.h	/^	BYTE rgbBlue; \/\/该颜色的蓝色分量$/;"	m	struct:tagRGBQUAD
rgbGreen	bitmap.h	/^	BYTE rgbGreen; \/\/该颜色的绿色分量$/;"	m	struct:tagRGBQUAD
rgbRed	bitmap.h	/^	BYTE rgbRed; \/\/该颜色的红色分量$/;"	m	struct:tagRGBQUAD
rgbReserved	bitmap.h	/^	BYTE rgbReserved; \/\/保留值$/;"	m	struct:tagRGBQUAD
riff_id	sound.h	/^  uint riff_id;$/;"	m	struct:wav
right	sh.c	/^  struct cmd *right;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
right	sh.c	/^  struct cmd *right;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
right_already_down	mouse.c	/^static int right_already_down = 0;$/;"	v	file:
right_click	clickable.h	/^	Clickable *right_click;$/;"	m	struct:ClickableManager
right_down	mouse.c	/^static int right_down = 0;$/;"	v	file:
right_x	window.h	/^	int right_x;$/;"	m	struct:Rect
right_y	window.h	/^	int right_y;$/;"	m	struct:Rect
rinode	mkfs.c	/^rinode(uint inum, struct dinode *ip)$/;"	f
rlen	sound.h	/^  uint rlen;$/;"	m	struct:wav
rmdot	usertests.c	/^rmdot(void)$/;"	f
rowLetterCnt	.asm	/^	rowLetterCnt = strlen(str);$/;"	d
rsect	mkfs.c	/^rsect(uint sec, void *buf)$/;"	f
rsv1	mmu.h	/^  uint rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segdesc
rsv1	mmu.h	/^  uint rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedesc
rtcdate	date.h	/^struct rtcdate {$/;"	s
run	kalloc.c	/^struct run {$/;"	s	file:
runcmd	sh.c	/^runcmd(struct cmd *cmd)$/;"	f
s	.asm	/^          s = "(null)";$/;"	d
s	.asm	/^        s = (char*)*ap;$/;"	d
s	cat.asm	/^          s = "(null)";$/;"	d
s	cat.asm	/^        s = (char*)*ap;$/;"	d
s	common.h	/^	int s[3][13];		\/* [window][cb] *\/$/;"	m	struct:__anon15
s	decode.asm	/^          s = "(null)";$/;"	d
s	decode.asm	/^        s = (char*)*ap;$/;"	d
s	decodemp3.c	/^	int s[14];$/;"	m	struct:__anon4	file:
s	decodemp3.c	/^	int s[3];$/;"	m	struct:__anon3	file:
s	echo.asm	/^          s = "(null)";$/;"	d
s	echo.asm	/^        s = (char*)*ap;$/;"	d
s	grep.asm	/^          s = "(null)";$/;"	d
s	grep.asm	/^        s = (char*)*ap;$/;"	d
s	init.asm	/^          s = "(null)";$/;"	d
s	init.asm	/^        s = (char*)*ap;$/;"	d
s	kill.asm	/^          s = "(null)";$/;"	d
s	kill.asm	/^        s = (char*)*ap;$/;"	d
s	ln.asm	/^          s = "(null)";$/;"	d
s	ln.asm	/^        s = (char*)*ap;$/;"	d
s	ls.asm	/^          s = "(null)";$/;"	d
s	ls.asm	/^        s = (char*)*ap;$/;"	d
s	mkdir.asm	/^          s = "(null)";$/;"	d
s	mkdir.asm	/^        s = (char*)*ap;$/;"	d
s	mmu.h	/^  uint s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedesc
s	mmu.h	/^  uint s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segdesc
s	pause.asm	/^          s = "(null)";$/;"	d
s	pause.asm	/^        s = (char*)*ap;$/;"	d
s	play.asm	/^          s = "(null)";$/;"	d
s	play.asm	/^        s = (char*)*ap;$/;"	d
s	umalloc.c	/^  } s;$/;"	m	union:header	typeref:struct:header::__anon6	file:
s_freq	common.c	/^double  s_freq[4] = {44.1, 48, 32, 0};$/;"	v
safestrcpy	string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f
sample_rate	sound.h	/^  uint sample_rate;$/;"	m	struct:fmt
sampling_frequency	common.h	/^    int sampling_frequency;$/;"	m	struct:__anon13
sb	mkfs.c	/^struct superblock sb;$/;"	v	typeref:struct:superblock
sblimit	common.h	/^    int         sblimit;        \/* Ӵ *\/$/;"	m	struct:frame_params
sbrktest	usertests.c	/^sbrktest(void)$/;"	f
scalefac_compress	common.h	/^			unsigned scalefac_compress;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
scalefac_scale	common.h	/^			unsigned scalefac_scale;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
scfsi	common.h	/^		unsigned scfsi[4];$/;"	m	struct:III_side_info_t::__anon14
sched	proc.c	/^sched(void)$/;"	f
scheduler	proc.c	/^scheduler(void)$/;"	f
scheduler	proc.h	/^  struct context *scheduler;   \/\/ swtch() here to enter scheduler$/;"	m	struct:cpu	typeref:struct:cpu::context
second	date.h	/^	uint second;$/;"	m	struct:rtcdate
sector	buf.h	/^  uint sector;$/;"	m	struct:buf
sector	log.c	/^  int sector[LOGSIZE];$/;"	m	struct:logheader	file:
seek_sync	common.c	/^int seek_sync(Bit_stream_struc *bs, unsigned long sync, int N)$/;"	f
segdesc	mmu.h	/^struct segdesc {$/;"	s
seginit	vm.c	/^seginit(void)$/;"	f
setActivated	window.c	/^void setActivated(WindowLink p)$/;"	f
setMouse	window.c	/^void setMouse(int x, int y)$/;"	f
setSoundSampleRate	sound.c	/^void setSoundSampleRate(uint samplerate)$/;"	f
set_icon_alpha	bitmap.c	/^void set_icon_alpha(PICNODE *pic)$/;"	f
setupkvm	vm.c	/^setupkvm(void)$/;"	f
sfBandIndex	decodemp3.c	/^} sfBandIndex[3]= {$/;"	v	typeref:struct:__anon4
sfbtable	decodemp3.c	/^} sfbtable = {$/;"	v	typeref:struct:__anon3
sharedfd	usertests.c	/^sharedfd(void)$/;"	f
shellinit	desktop.c	/^int shellinit(Point point)$/;"	f
shentsize	elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr
shiftcode	kbd.h	/^static uchar shiftcode[256] =$/;"	v
shiftmap	kbd.h	/^static uchar shiftmap[256] =$/;"	v
shnum	elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr
shoff	elf.h	/^  uint shoff;$/;"	m	struct:elfhdr
showBmpHead	bitmap.c	/^void showBmpHead(BITMAPFILEHEADER* pBmpHead)$/;"	f
showBmpInforHead	bitmap.c	/^void showBmpInforHead(BITMAPINFOHEADER* pBmpInforHead)$/;"	f
showRgbQuan	bitmap.c	/^void showRgbQuan(RGBQUAD* pRGB)$/;"	f
show_text	editor.c	/^void show_text(char *text[])$/;"	f
shstrndx	elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr
signature	mp.h	/^  uchar signature[4];           \/\/ "PCMP"$/;"	m	struct:mpconf
signature	mp.h	/^  uchar signature[4];           \/\/ "_MP_"$/;"	m	struct:mp
signature	mp.h	/^  uchar signature[4];           \/\/ CPU signature$/;"	m	struct:mpproc
sin	math.c	/^double sin(double x)  $/;"	f
size	.asm	/^			size = sizeFormat(st.size);$/;"	d
size	.asm	/^		size = size \/ (0x400);$/;"	d
size	drawingAPI.h	/^	int size;$/;"	m	struct:File_Node
size	file.h	/^  uint size;$/;"	m	struct:inode
size	fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode
size	fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock
size	log.c	/^  int size;$/;"	m	struct:log	file:
size	mkfs.c	/^int size = 1024 * 1024;$/;"	v
size	stat.h	/^  uint size;   \/\/ Size of file in bytes$/;"	m	struct:stat
size	sysaudio.c	/^int size;$/;"	v
size	umalloc.c	/^    uint size;$/;"	m	struct:header::__anon6	file:
sizeFormat	finder.c	/^char *sizeFormat(uint size){$/;"	f
skipelem	fs.c	/^skipelem(char *path, char *name)$/;"	f	file:
sleep	proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f
slen	decodemp3.c	/^int slen[2][16]={$/;"	v
snd	sysaudio.c	/^struct snd {$/;"	s	file:
sndlock	sysaudio.c	/^struct snd sndlock;$/;"	v	typeref:struct:snd
soundInterrupt	sound.c	/^void soundInterrupt(void)$/;"	f
soundLock	sound.c	/^static struct spinlock soundLock;$/;"	v	typeref:struct:spinlock	file:
soundNode	sound.h	/^struct soundNode{$/;"	s
soundQueue	sound.c	/^static struct soundNode *soundQueue;$/;"	v	typeref:struct:soundNode	file:
soundcardinit	sound.c	/^soundcardinit(uchar bus, uchar slot, uchar func)$/;"	f
soundinit	sound.c	/^void soundinit(void)$/;"	f
specrev	mp.h	/^  uchar specrev;                \/\/ [14]$/;"	m	struct:mp
spin	bootasm.S	/^spin:$/;"	l
spin	entryother.S	/^spin:$/;"	l
spinlock	spinlock.h	/^struct spinlock {$/;"	s
splice	splice.c	/^splice(int num, char *src_files[], char* dst_file){\/\/源文件数、源文件名[]、目标文件名$/;"	f
split	cal.c	/^char** split(char* src)$/;"	f
sqrt	math.c	/^double sqrt(double x)$/;"	f
src	.asm	/^  src = vsrc;$/;"	d
src	cat.asm	/^  src = vsrc;$/;"	d
src	decode.asm	/^  src = vsrc;$/;"	d
src	echo.asm	/^  src = vsrc;$/;"	d
src	forktest.asm	/^  src = vsrc;$/;"	d
src	grep.asm	/^  src = vsrc;$/;"	d
src	init.asm	/^  src = vsrc;$/;"	d
src	kill.asm	/^  src = vsrc;$/;"	d
src	ln.asm	/^  src = vsrc;$/;"	d
src	ls.asm	/^  src = vsrc;$/;"	d
src	mkdir.asm	/^  src = vsrc;$/;"	d
src	pause.asm	/^  src = vsrc;$/;"	d
src	play.asm	/^  src = vsrc;$/;"	d
ss	mmu.h	/^  ushort ss;$/;"	m	struct:taskstate
ss	x86.h	/^  ushort ss;$/;"	m	struct:trapframe
ss0	mmu.h	/^  ushort ss0;        \/\/   after an increase in privilege level$/;"	m	struct:taskstate
ss1	mmu.h	/^  ushort ss1;$/;"	m	struct:taskstate
ss2	mmu.h	/^  ushort ss2;$/;"	m	struct:taskstate
sstell	common.c	/^unsigned long sstell(Bit_stream_struc *bs)$/;"	f
st	finder.c	/^	struct stat st;$/;"	m	struct:fileItem	typeref:struct:fileItem::stat	file:
start	bootasm.S	/^start:$/;"	l
start	clickable.h	/^	Point start;$/;"	m	struct:Rect
start	entryother.S	/^start:$/;"	l
start	initcode.S	/^start:$/;"	l
start	log.c	/^  int start;$/;"	m	struct:log	file:
start32	bootasm.S	/^start32:$/;"	l
start32	entryother.S	/^start32:$/;"	l
started	proc.h	/^  volatile uint started;       \/\/ Has the CPU started?$/;"	m	struct:cpu
startothers	main.c	/^startothers(void)$/;"	f	file:
stat	mkfs.c	8;"	d	file:
stat	stat.h	/^struct stat {$/;"	s
stat	ulib.c	/^stat(char *n, struct stat *st)$/;"	f
state	.asm	/^        state = '%';$/;"	d
state	.asm	/^      state = 0;$/;"	d
state	.asm	/^  state = 0;$/;"	d
state	cat.asm	/^        state = '%';$/;"	d
state	cat.asm	/^      state = 0;$/;"	d
state	cat.asm	/^  state = 0;$/;"	d
state	decode.asm	/^        state = '%';$/;"	d
state	decode.asm	/^      state = 0;$/;"	d
state	decode.asm	/^  state = 0;$/;"	d
state	echo.asm	/^        state = '%';$/;"	d
state	echo.asm	/^      state = 0;$/;"	d
state	echo.asm	/^  state = 0;$/;"	d
state	grep.asm	/^        state = '%';$/;"	d
state	grep.asm	/^      state = 0;$/;"	d
state	grep.asm	/^  state = 0;$/;"	d
state	init.asm	/^        state = '%';$/;"	d
state	init.asm	/^      state = 0;$/;"	d
state	init.asm	/^  state = 0;$/;"	d
state	kill.asm	/^        state = '%';$/;"	d
state	kill.asm	/^      state = 0;$/;"	d
state	kill.asm	/^  state = 0;$/;"	d
state	ln.asm	/^        state = '%';$/;"	d
state	ln.asm	/^      state = 0;$/;"	d
state	ln.asm	/^  state = 0;$/;"	d
state	ls.asm	/^        state = '%';$/;"	d
state	ls.asm	/^      state = 0;$/;"	d
state	ls.asm	/^  state = 0;$/;"	d
state	mkdir.asm	/^        state = '%';$/;"	d
state	mkdir.asm	/^      state = 0;$/;"	d
state	mkdir.asm	/^  state = 0;$/;"	d
state	mouse.c	/^static int state = 0;$/;"	v	file:
state	pause.asm	/^        state = '%';$/;"	d
state	pause.asm	/^      state = 0;$/;"	d
state	pause.asm	/^  state = 0;$/;"	d
state	play.asm	/^        state = '%';$/;"	d
state	play.asm	/^      state = 0;$/;"	d
state	play.asm	/^  state = 0;$/;"	d
state	proc.h	/^  enum procstate state;        \/\/ Process state$/;"	m	struct:proc	typeref:enum:proc::procstate
stati	fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f
static	.asm	/^static Header *freep;$/;"	l
static	.asm	/^static Header base;$/;"	l
static	.asm	/^static Header*$/;"	l
static	.asm	/^static inline void$/;"	l
static	.asm	/^static void$/;"	l
static	cat.asm	/^static Header *freep;$/;"	l
static	cat.asm	/^static Header base;$/;"	l
static	cat.asm	/^static Header*$/;"	l
static	cat.asm	/^static inline void$/;"	l
static	cat.asm	/^static void$/;"	l
static	decode.asm	/^static Header *freep;$/;"	l
static	decode.asm	/^static Header base;$/;"	l
static	decode.asm	/^static Header*$/;"	l
static	decode.asm	/^static inline void$/;"	l
static	decode.asm	/^static void$/;"	l
static	echo.asm	/^static Header *freep;$/;"	l
static	echo.asm	/^static Header base;$/;"	l
static	echo.asm	/^static Header*$/;"	l
static	echo.asm	/^static inline void$/;"	l
static	echo.asm	/^static void$/;"	l
static	forktest.asm	/^static inline void$/;"	l
static	grep.asm	/^static Header *freep;$/;"	l
static	grep.asm	/^static Header base;$/;"	l
static	grep.asm	/^static Header*$/;"	l
static	grep.asm	/^static inline void$/;"	l
static	grep.asm	/^static void$/;"	l
static	init.asm	/^static Header *freep;$/;"	l
static	init.asm	/^static Header base;$/;"	l
static	init.asm	/^static Header*$/;"	l
static	init.asm	/^static inline void$/;"	l
static	init.asm	/^static void$/;"	l
static	kill.asm	/^static Header *freep;$/;"	l
static	kill.asm	/^static Header base;$/;"	l
static	kill.asm	/^static Header*$/;"	l
static	kill.asm	/^static inline void$/;"	l
static	kill.asm	/^static void$/;"	l
static	ln.asm	/^static Header *freep;$/;"	l
static	ln.asm	/^static Header base;$/;"	l
static	ln.asm	/^static Header*$/;"	l
static	ln.asm	/^static inline void$/;"	l
static	ln.asm	/^static void$/;"	l
static	ls.asm	/^static Header *freep;$/;"	l
static	ls.asm	/^static Header base;$/;"	l
static	ls.asm	/^static Header*$/;"	l
static	ls.asm	/^static inline void$/;"	l
static	ls.asm	/^static void$/;"	l
static	mkdir.asm	/^static Header *freep;$/;"	l
static	mkdir.asm	/^static Header base;$/;"	l
static	mkdir.asm	/^static Header*$/;"	l
static	mkdir.asm	/^static inline void$/;"	l
static	mkdir.asm	/^static void$/;"	l
static	pause.asm	/^static Header *freep;$/;"	l
static	pause.asm	/^static Header base;$/;"	l
static	pause.asm	/^static Header*$/;"	l
static	pause.asm	/^static inline void$/;"	l
static	pause.asm	/^static void$/;"	l
static	play.asm	/^static Header *freep;$/;"	l
static	play.asm	/^static Header base;$/;"	l
static	play.asm	/^static Header*$/;"	l
static	play.asm	/^static inline void$/;"	l
static	play.asm	/^static void$/;"	l
static_assert	mkfs.c	14;"	d	file:
stdout	usertests.c	/^int stdout = 1;$/;"	v
stereo	common.h	/^    int         stereo;         \/* 1 Ϊ mono, 2 Ϊ stereo *\/$/;"	m	struct:frame_params
sti	x86.h	/^sti(void)$/;"	f
stosb	x86.h	/^stosb(void *addr, int data, int cnt)$/;"	f
stosl	x86.h	/^stosl(void *addr, int data, int cnt)$/;"	f
strcat_n	editor.c	/^char* strcat_n(char* dest, char* src, int len)$/;"	f
strchr	ulib.c	/^strchr(const char *s, char c)$/;"	f
strcmp	ulib.c	/^strcmp(const char *p, const char *q)$/;"	f
strcpy	ulib.c	/^strcpy(char *s, char *t)$/;"	f
stringtonumber	editor.c	/^int stringtonumber(char* src)$/;"	f
strlen	string.c	/^strlen(const char *s)$/;"	f
strlen	ulib.c	/^strlen(char *s)$/;"	f
strmatch	console.c	/^strmatch(const char *s, const char *m)$/;"	f
strncmp	string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f
strncpy	string.c	/^strncpy(char *s, const char *t, int n)$/;"	f
style	.asm	/^	style = ICON_STYLE;$/;"	d
style	.asm	/^	style = LIST_STYLE;$/;"	d
style	finder.c	/^int style = LIST_STYLE; \/\/绘制风格$/;"	v
subblock_gain	common.h	/^			unsigned subblock_gain[3];$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
subdir	usertests.c	/^subdir(void)$/;"	f
sum	mp.c	/^sum(uchar *addr, int len)$/;"	f	file:
superblock	fs.h	/^struct superblock {$/;"	s
switchkvm	vm.c	/^switchkvm(void)$/;"	f
switchuvm	vm.c	/^switchuvm(struct proc *p)$/;"	f
swtch	swtch.S	/^swtch:$/;"	l
symbols	sh.c	/^char symbols[] = "<|>&;";$/;"	v
sys_beginDecode	sysaudio.c	/^sys_beginDecode(void)$/;"	f
sys_chdir	sysfile.c	/^sys_chdir(void)$/;"	f
sys_close	sysfile.c	/^sys_close(void)$/;"	f
sys_createWindow	syswindow.c	/^int sys_createWindow()$/;"	f
sys_destroyWindow	syswindow.c	/^int sys_destroyWindow()$/;"	f
sys_dup	sysfile.c	/^sys_dup(void)$/;"	f
sys_endDecode	sysaudio.c	/^int sys_endDecode(void)$/;"	f
sys_exec	sysfile.c	/^sys_exec(void)$/;"	f
sys_exit	sysproc.c	/^sys_exit(void)$/;"	f
sys_fork	sysproc.c	/^sys_fork(void)$/;"	f
sys_fstat	sysfile.c	/^sys_fstat(void)$/;"	f
sys_getCoreBuf	sysaudio.c	/^int sys_getCoreBuf(void)$/;"	f
sys_getMsg	message.c	/^int sys_getMsg()$/;"	f
sys_getpid	sysproc.c	/^sys_getpid(void)$/;"	f
sys_kill	sysproc.c	/^sys_kill(void)$/;"	f
sys_kwrite	sysaudio.c	/^sys_kwrite(void)$/;"	f
sys_link	sysfile.c	/^sys_link(void)$/;"	f
sys_mkdir	sysfile.c	/^sys_mkdir(void)$/;"	f
sys_mknod	sysfile.c	/^sys_mknod(void)$/;"	f
sys_open	sysfile.c	/^sys_open(void)$/;"	f
sys_pause	sysaudio.c	/^sys_pause(void)$/;"	f
sys_pipe	sysfile.c	/^sys_pipe(void)$/;"	f
sys_read	sysfile.c	/^sys_read(void)$/;"	f
sys_sbrk	sysproc.c	/^sys_sbrk(void)$/;"	f
sys_setSampleRate	sysaudio.c	/^int sys_setSampleRate(void)$/;"	f
sys_sleep	sysproc.c	/^sys_sleep(void)$/;"	f
sys_unlink	sysfile.c	/^sys_unlink(void)$/;"	f
sys_updatePartialWindow	syswindow.c	/^int sys_updatePartialWindow()$/;"	f
sys_updateWindow	syswindow.c	/^int sys_updateWindow()$/;"	f
sys_uptime	sysproc.c	/^sys_uptime(void)$/;"	f
sys_wait	sysproc.c	/^sys_wait(void)$/;"	f
sys_waitForDecode	sysaudio.c	/^sys_waitForDecode(void)$/;"	f
sys_wavdecode	sysaudio.c	/^sys_wavdecode(void)$/;"	f
sys_write	sysfile.c	/^sys_write(void)$/;"	f
syscall	syscall.c	/^syscall(void)$/;"	f
syscalls	syscall.c	/^static int (*syscalls[])(void) = {$/;"	v	file:
sz	proc.h	/^  uint sz;                     \/\/ Size of process memory (bytes)$/;"	m	struct:proc
t	mmu.h	/^  ushort t;          \/\/ Trap on task switch$/;"	m	struct:taskstate
table	huffman.h	/^  HUFFBITS *table;	\/*ָarray[xlen][ylen]ָ		*\/$/;"	m	struct:huffcodetab
table_select	common.h	/^			unsigned table_select[3];$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
tablename	huffman.h	/^  char tablename[3];	\/*ַ,  table_description	*\/$/;"	m	struct:huffcodetab
tag	sysaudio.c	/^    uint tag;$/;"	m	struct:snd	file:
tagBITMAPFILEHEADER	bitmap.h	/^typedef struct tagBITMAPFILEHEADER {$/;"	s
tagBITMAPINFOHEADER	bitmap.h	/^typedef struct tagBITMAPINFOHEADER{$/;"	s
tagRGBQUAD	bitmap.h	/^typedef struct tagRGBQUAD {$/;"	s
tan	math.c	/^double tan(double x)  $/;"	f
taskstate	mmu.h	/^struct taskstate {$/;"	s
temp	.asm	/^				temp = *head;$/;"	d
temp	.asm	/^				temp = cur;$/;"	d
temp	.asm	/^		temp = p;$/;"	d
testClickable	clickable.c	/^void testClickable(struct Context c)$/;"	f
testHandlers	finder.c	/^void testHandlers() {$/;"	f
testHanler	clickable.c	/^void testHanler(struct Point p)$/;"	f
tf	proc.h	/^  struct trapframe *tf;        \/\/ Trap frame for current syscall$/;"	m	struct:proc	typeref:struct:proc::trapframe
the_layer	common.h	/^} layer, *the_layer;$/;"	t	typeref:struct:__anon13
ticks	trap.c	/^uint ticks;$/;"	v
tickslock	trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
timerinit	timer.c	/^timerinit(void)$/;"	f
toRPN	cal.c	/^char** toRPN(char** src)$/;"	f
togglecode	kbd.h	/^static uchar togglecode[256] =$/;"	v
top	console.c	/^	uint top;$/;"	m	struct:__anon10	file:
totbit	common.h	/^    long        totbit;         \/* ıؼ *\/$/;"	m	struct:bit_stream_struc
totbit	sound.h	/^	unsigned long offset, totbit, buf_byte_idx;$/;"	m	struct:coreBuf
trap	trap.c	/^trap(struct trapframe *tf)$/;"	f
trapframe	x86.h	/^struct trapframe {$/;"	s
trapno	x86.h	/^  uint trapno;$/;"	m	struct:trapframe
trapret	trapasm.S	/^trapret:$/;"	l
treelen	huffman.h	/^  unsigned int treelen;	\/*		*\/$/;"	m	struct:huffcodetab
ts	proc.h	/^  struct taskstate ts;         \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:cpu	typeref:struct:cpu::taskstate
tvinit	trap.c	/^tvinit(void)$/;"	f
type	elf.h	/^  uint type;$/;"	m	struct:proghdr
type	elf.h	/^  ushort type;$/;"	m	struct:elfhdr
type	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon12
type	file.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode
type	fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode
type	mmu.h	/^  uint type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:gatedesc
type	mmu.h	/^  uint type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segdesc
type	mp.h	/^  uchar type;                   \/\/ MP system config type$/;"	m	struct:mp
type	mp.h	/^  uchar type;                   \/\/ entry type (0)$/;"	m	struct:mpproc
type	mp.h	/^  uchar type;                   \/\/ entry type (2)$/;"	m	struct:mpioapic
type	sh.c	/^  int type;$/;"	m	struct:backcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:cmd	file:
type	sh.c	/^  int type;$/;"	m	struct:execcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:listcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:pipecmd	file:
type	sh.c	/^  int type;$/;"	m	struct:redircmd	file:
type	stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat
uart	uart.c	/^static int uart;    \/\/ is there a uart?$/;"	v	file:
uartgetc	uart.c	/^uartgetc(void)$/;"	f	file:
uartinit	uart.c	/^uartinit(void)$/;"	f
uartintr	uart.c	/^uartintr(void)$/;"	f
uartputc	uart.c	/^uartputc(int c)$/;"	f
uchar	types.h	/^typedef unsigned char  uchar;$/;"	t
uint	.asm	/^uint$/;"	l
uint	cat.asm	/^uint$/;"	l
uint	decode.asm	/^uint$/;"	l
uint	echo.asm	/^uint$/;"	l
uint	forktest.asm	/^uint$/;"	l
uint	grep.asm	/^uint$/;"	l
uint	init.asm	/^uint$/;"	l
uint	kill.asm	/^uint$/;"	l
uint	ln.asm	/^uint$/;"	l
uint	ls.asm	/^uint$/;"	l
uint	mkdir.asm	/^uint$/;"	l
uint	pause.asm	/^uint$/;"	l
uint	play.asm	/^uint$/;"	l
uint	types.h	/^typedef unsigned int   uint;$/;"	t
uninit	usertests.c	/^char uninit[10000];$/;"	v
unlinkread	usertests.c	/^unlinkread(void)$/;"	f
unsigned	.asm	/^unsigned char *hankaku;$/;"	l
use_lock	kalloc.c	/^  int use_lock;$/;"	m	struct:__anon8	file:
usedblocks	mkfs.c	/^uint usedblocks;$/;"	v
userinit	proc.c	/^userinit(void)$/;"	f
ushort	types.h	/^typedef unsigned short ushort;$/;"	t
uva2ka	vm.c	/^uva2ka(pde_t *pgdir, char *uva)$/;"	f
v2p	memlayout.h	/^static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }$/;"	f
vaddr	elf.h	/^  uint vaddr;$/;"	m	struct:proghdr
val	huffman.h	/^  unsigned char(*val)[2];\/*				*\/ $/;"	m	struct:huffcodetab
validateint	usertests.c	/^validateint(int *p)$/;"	f
validatetest	usertests.c	/^validatetest(void)$/;"	f
vegamodeinit	vegamode.c	/^void vegamodeinit()$/;"	f
version	common.h	/^    int version;$/;"	m	struct:__anon13
version	elf.h	/^  uint version;$/;"	m	struct:elfhdr
version	mp.h	/^  uchar version;                \/\/ I\/O APIC version$/;"	m	struct:mpioapic
version	mp.h	/^  uchar version;                \/\/ [14]$/;"	m	struct:mpconf
version	mp.h	/^  uchar version;                \/\/ local APIC verison$/;"	m	struct:mpproc
vesa_array	window.c	/^static color16* vesa_array;$/;"	v	file:
vesa_buffer	window.c	/^static color16 vesa_buffer[480000];$/;"	v	file:
vesamodeinit	vesamode.c	/^void vesamodeinit()$/;"	f
virt	vm.c	/^  void *virt;$/;"	m	struct:kmap	file:
void	.asm	/^void $/;"	l
void	.asm	/^void addClickable(Clickable **head, Rect r, Handler h)$/;"	l
void	.asm	/^void addFileItem(struct stat st, char *name, Rect pos) {$/;"	l
void	.asm	/^void addItemEvent(ClickableManager *cm, struct fileItem item) {$/;"	l
void	.asm	/^void addListEvent(ClickableManager *cm) {$/;"	l
void	.asm	/^void addWndEvent(ClickableManager *cm) {$/;"	l
void	.asm	/^void createClickable(ClickableManager *c, Rect r, int MsgType, Handler h)$/;"	l
void	.asm	/^void deleteClickable(Clickable **head, Rect region)$/;"	l
void	.asm	/^void deleteFile(char *name)$/;"	l
void	.asm	/^void drawFinderContent(Context context) {$/;"	l
void	.asm	/^void drawFinderWnd(Context context) {$/;"	l
void	.asm	/^void drawItem(Context context, char *name, struct stat st, Rect rect, int chosen) {$/;"	l
void	.asm	/^void draw_iconlist(Context c, ICON* iconlist, int len)$/;"	l
void	.asm	/^void draw_line(Context c, int x0, int y0, int x1, int y1, unsigned short color)$/;"	l
void	.asm	/^void draw_picture(Context c, PICNODE pic, int x, int y)$/;"	l
void	.asm	/^void enterDir(char *name) {$/;"	l
void	.asm	/^void freeASCII(){$/;"	l
void	.asm	/^void freeFileItemList() {$/;"	l
void	.asm	/^void freeGBK(){$/;"	l
void	.asm	/^void free_context(struct Context* context_ptr, int winid)$/;"	l
void	.asm	/^void freepic(PICNODE *pic)$/;"	l
void	.asm	/^void h_chooseFile(Point p) {$/;"	l
void	.asm	/^void h_chvm1(Point p) {$/;"	l
void	.asm	/^void h_chvm2(Point p) {$/;"	l
void	.asm	/^void h_closeWnd(Point p) {$/;"	l
void	.asm	/^void h_deleteFile(Point p) {$/;"	l
void	.asm	/^void h_empty(Point p) {$/;"	l
void	.asm	/^void h_enterDir(Point p) {$/;"	l
void	.asm	/^void h_goUp(Point p) {$/;"	l
void	.asm	/^void h_newFile(Point p) {$/;"	l
void	.asm	/^void h_newFolder(Point p) {$/;"	l
void	.asm	/^void initializeASCII()$/;"	l
void	.asm	/^void initializeGBK(){$/;"	l
void	.asm	/^void list(char *path) {$/;"	l
void	.asm	/^void loadBitmap(PICNODE *pic, char pic_name[])$/;"	l
void	.asm	/^void load_iconlist(ICON* iconlist, int len)$/;"	l
void	.asm	/^void newFile(char *name) {$/;"	l
void	.asm	/^void newFolder(char *name) {$/;"	l
void	.asm	/^void printBinary(char c)$/;"	l
void	.asm	/^void printClickable(Clickable *c)$/;"	l
void	.asm	/^void printClickableList(Clickable *head)$/;"	l
void	.asm	/^void printItemList() {$/;"	l
void	.asm	/^void printItemList();$/;"	l
void	.asm	/^void put_ascii(struct Context c, unsigned char ascii, unsigned short colorNum, int x, int y)$/;"	l
void	.asm	/^void put_gbk(struct Context c, short gbk, unsigned short colorNum, int x, int y)$/;"	l
void	.asm	/^void puts_str(struct Context c, char *str, unsigned short colorNum, int x, int y)$/;"	l
void	.asm	/^void set_icon_alpha(PICNODE *pic)$/;"	l
void	.asm	/^void showBmpHead(BITMAPFILEHEADER* pBmpHead)$/;"	l
void	.asm	/^void showBmpHead(BITMAPFILEHEADER* pBmpHead);$/;"	l
void	.asm	/^void showBmpInforHead(BITMAPINFOHEADER* pBmpInforHead)$/;"	l
void	.asm	/^void showBmpInforHead(BITMAPINFOHEADER* pBmpInforHead);$/;"	l
void	.asm	/^void showRgbQuan(RGBQUAD* pRGB)$/;"	l
void	.asm	/^void showRgbQuan(RGBQUAD* pRGB);$/;"	l
void	.asm	/^void testClickable(struct Context c)$/;"	l
void	.asm	/^void testHandlers() {$/;"	l
void	.asm	/^void testHandlers();$/;"	l
void	.asm	/^void testHanler(struct Point p)$/;"	l
void	.asm	/^void$/;"	l
void	cat.asm	/^void$/;"	l
void	decode.asm	/^void$/;"	l
void	echo.asm	/^void$/;"	l
void	forktest.asm	/^void$/;"	l
void	grep.asm	/^void$/;"	l
void	init.asm	/^void$/;"	l
void	kill.asm	/^void$/;"	l
void	ln.asm	/^void$/;"	l
void	ls.asm	/^void$/;"	l
void	mkdir.asm	/^void$/;"	l
void	pause.asm	/^void$/;"	l
void	play.asm	/^void$/;"	l
w	console.c	/^	uint w;  \/\/ Write index$/;"	m	struct:__anon9	file:
wait	proc.c	/^wait(void)$/;"	f
waitdisk	bootmain.c	/^waitdisk(void)$/;"	f
wakeup	proc.c	/^wakeup(void *chan)$/;"	f
wakeup1	proc.c	/^wakeup1(void *chan)$/;"	f	file:
walkpgdir	vm.c	/^walkpgdir(pde_t *pgdir, const void *va, int alloc)$/;"	f	file:
wav	sound.h	/^struct wav{$/;"	s
wave_id	sound.h	/^  uint wave_id;$/;"	m	struct:wav
wc	wc.c	/^wc(int fd, char *name)$/;"	f
whitespace	sh.c	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	v
width	.asm	/^	width = bitInfoHead.biWidth;$/;"	d
width	bitmap.h	/^	int width;$/;"	m	struct:PicNode
width	clickable.h	/^	int width;$/;"	m	struct:Rect
width	context.h	/^	int width;$/;"	m	struct:Context
window_array	window.c	/^Window window_array[MAXWINDOW];$/;"	v
window_id	window.h	/^	int window_id;$/;"	m	struct:Window
window_list	window.c	/^WindowLink window_list = 0;$/;"	v
window_position	window.h	/^	Rect window_position;$/;"	m	struct:Window
window_switching_flag	common.h	/^			unsigned window_switching_flag;$/;"	m	struct:III_side_info_t::__anon14::gr_info_s
windowlistinit	window.c	/^void windowlistinit()$/;"	f
winid	.asm	/^	winid = init_context(&context, WINDOW_WIDTH, WINDOW_HEIGHT);$/;"	d
winode	mkfs.c	/^winode(uint inum, struct dinode *ip)$/;"	f
wndEvents	finder.c	/^Handler wndEvents[] = { h_closeWnd, h_empty, h_chvm2, h_chvm1, h_newFolder,$/;"	v
wndHeight	clickable.h	/^	int wndHeight;$/;"	m	struct:ClickableManager
wndRes	finder.c	/^struct Icon wndRes[] = { { "close.bmp", 3, 3 }, { "foldericon.bmp", WINDOW_WIDTH$/;"	v	typeref:struct:Icon
wndWidth	clickable.h	/^	int wndWidth;$/;"	m	struct:ClickableManager
writable	file.h	/^  char writable;$/;"	m	struct:file
write	file.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw
write_bet_fds	splice.c	/^write_bet_fds(int src_fd, int dst_fd){\/\/把src_fd粘到dst_fd后，pattern表示是否加行号$/;"	f
write_head	log.c	/^write_head(void)$/;"	f	file:
write_log	log.c	/^write_log(void)$/;"	f	file:
write_pci_config	sound.c	/^void write_pci_config(uchar bus, uchar slot, uchar func, uchar offset, uint val)$/;"	f
writefile	cuth	/^sub writefile($@){$/;"	s
writei	fs.c	/^writei(struct inode *ip, char *src, uint off, uint n)$/;"	f
writeopen	pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:
writetest	usertests.c	/^writetest(void)$/;"	f
writetest1	usertests.c	/^writetest1(void)$/;"	f
wsect	mkfs.c	/^wsect(uint sec, void *buf)$/;"	f
x	.asm	/^					x = 0;$/;"	d
x	.asm	/^	x = 0;$/;"	d
x	.asm	/^	x = x0 << 10;$/;"	d
x	.asm	/^    x = -xx;$/;"	d
x	.asm	/^    x = xx;$/;"	d
x	cat.asm	/^    x = -xx;$/;"	d
x	cat.asm	/^    x = xx;$/;"	d
x	clickable.h	/^	int x;$/;"	m	struct:Point
x	decode.asm	/^    x = -xx;$/;"	d
x	decode.asm	/^    x = xx;$/;"	d
x	echo.asm	/^    x = -xx;$/;"	d
x	echo.asm	/^    x = xx;$/;"	d
x	grep.asm	/^    x = -xx;$/;"	d
x	grep.asm	/^    x = xx;$/;"	d
x	init.asm	/^    x = -xx;$/;"	d
x	init.asm	/^    x = xx;$/;"	d
x	kill.asm	/^    x = -xx;$/;"	d
x	kill.asm	/^    x = xx;$/;"	d
x	ln.asm	/^    x = -xx;$/;"	d
x	ln.asm	/^    x = xx;$/;"	d
x	ls.asm	/^    x = -xx;$/;"	d
x	ls.asm	/^    x = xx;$/;"	d
x	message.h	/^	int x;$/;"	m	struct:MsgMouse
x	mkdir.asm	/^    x = -xx;$/;"	d
x	mkdir.asm	/^    x = xx;$/;"	d
x	pause.asm	/^    x = -xx;$/;"	d
x	pause.asm	/^    x = xx;$/;"	d
x	play.asm	/^    x = -xx;$/;"	d
x	play.asm	/^    x = xx;$/;"	d
x	umalloc.c	/^  Align x;$/;"	m	union:header	file:
x1	message.h	/^    int x1;$/;"	m	struct:MsgPartialUpdate
x2	message.h	/^    int x2;$/;"	m	struct:MsgPartialUpdate
x_drag_start	mouse.c	/^static int x_drag_start = 0;$/;"	v	file:
x_large_dispalecement	mouse.c	/^static int x_large_dispalecement = 0;$/;"	v	file:
x_overflow	mouse.c	/^static int x_overflow = 0;$/;"	v	file:
x_position	mouse.c	/^static int x_position = 0;$/;"	v	file:
x_sign	mouse.c	/^static int x_sign = 0;$/;"	v	file:
xchecksum	mp.h	/^  uchar xchecksum;              \/\/ extended table checksum$/;"	m	struct:mpconf
xchg	x86.h	/^xchg(volatile uint *addr, uint newval)$/;"	f
xint	mkfs.c	/^xint(uint x)$/;"	f
xlen	huffman.h	/^  unsigned int xlen; 	$/;"	m	struct:huffcodetab
xlength	mp.h	/^  ushort xlength;               \/\/ extended table length$/;"	m	struct:mpconf
xshort	mkfs.c	/^xshort(ushort x)$/;"	f
y	.asm	/^	y = 0;$/;"	d
y	.asm	/^	y = y0 << 10;$/;"	d
y	clickable.h	/^	int y;$/;"	m	struct:Point
y	message.h	/^	int y;$/;"	m	struct:MsgMouse
y1	message.h	/^    int y1;$/;"	m	struct:MsgPartialUpdate
y2	message.h	/^    int y2;$/;"	m	struct:MsgPartialUpdate
y_drag_start	mouse.c	/^static int y_drag_start = 0;$/;"	v	file:
y_large_dispalecement	mouse.c	/^static int y_large_dispalecement = 0;$/;"	v	file:
y_overflow	mouse.c	/^static int y_overflow = 0;$/;"	v	file:
y_position	mouse.c	/^static int y_position = 0;$/;"	v	file:
y_sign	mouse.c	/^static int y_sign = 0;$/;"	v	file:
year	date.h	/^	uint year;$/;"	m	struct:rtcdate
yield	proc.c	/^yield(void)$/;"	f
ylen	huffman.h	/^  unsigned int ylen;	$/;"	m	struct:huffcodetab
zeroes	mkfs.c	/^char zeroes[512];$/;"	v
